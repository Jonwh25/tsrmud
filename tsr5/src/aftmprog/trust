act_clan.c:    if (ch->clan != 1 || ch->clev < 5) {
act_clan.c:    if (victim->clan != ch->clan) {
act_clan.c:    if (ch->clan != 1 || !IS_SET(ch->act, PLR_CSKILL)
act_clan.c:	chance = (ch->level * 75) / obj->level;
act_clan.c:    if (ch->clan != -1) {
act_clan.c:    af.level = ch->level;
act_clan.c:    if (ch->clan != 8) {
act_clan.c:    if (ch->fighting || ch->ctimer || IS_AFFECTED2(ch, AFF_UNHOLYSTRENGTH)) {
act_clan.c:    af.level = ch->level;
act_clan.c:/*  ch->ctimer = 17; */
act_clan.c:    if (ch->clan != 3) {
act_clan.c:    if (ch->ctimer || ch->combat_timer) {
act_clan.c:    af.level = ch->level;
act_clan.c:    ch->ctimer = af.duration + 10;
act_comm.c:    if ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_SILENCE ) )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENT ) 
act_comm.c:    REMOVE_BIT( ch->deaf, channel );
act_comm.c:	position        = ch->position;
act_comm.c:	ch->position    = POS_STANDING;
act_comm.c:	ch->position    = position;
act_comm.c:        sprintf( buf, "{R[{g%s{R]{g $n: '$t'{x", (ch->guild != NULL)
act_comm.c:         ? ch->guild->name : "NONE");
act_comm.c:        position        = ch->position;
act_comm.c:        ch->position   = POS_STANDING;
act_comm.c:        ch->position    = position;
act_comm.c:	       ( get_clan_index(ch->clan) && (get_clan_index(ch->clan))->name ?
act_comm.c:		(get_clan_index(ch->clan))->name : "Unclanned") );
act_comm.c:        position        = ch->position;
act_comm.c:        ch->position   = POS_STANDING;
act_comm.c:        ch->position    = position;
act_comm.c:        position        = ch->position;
act_comm.c:        ch->position   = POS_STANDING;
act_comm.c:        ch->position    = position;
act_comm.c:        position        = ch->position;
act_comm.c:        ch->position    = POS_STANDING;
act_comm.c:        ch->position    = position;
act_comm.c:	position	= ch->position;
act_comm.c:	ch->position	= POS_STANDING;
act_comm.c:	ch->position	= position;
act_comm.c:	position	= ch->position;
act_comm.c:	ch->position	= POS_STANDING;
act_comm.c:	ch->position	= position;
act_comm.c:	    && !IS_SET( och->deaf, channel ) 
act_comm.c:	    && !IS_SET( och->in_room->room_flags, ROOM_SILENT ) )
act_comm.c:	    if ( channel == CHANNEL_VENT && och->level < 3 ) 
act_comm.c:                 if ( IS_SET( och->deaf, CHANNEL_CLASS_MASTER ) ||
act_comm.c:                && ( vch->guild != ch->guild ) )
act_comm.c:                  if ( IS_SET( och->deaf, CHANNEL_GUILD_MASTER ) ||
act_comm.c:                && ( vch->clan != ch->clan ) )
act_comm.c:                  if ( IS_SET( och->deaf, CHANNEL_CLAN_MASTER ) ||
act_comm.c:		&& vch->in_room->area != ch->in_room->area )
act_comm.c:	    if ( ( !IS_SET( ch->in_room->area->area_flags, AREA_MUDSCHOOL ) )
act_comm.c:		 && ( ch->level < LEVEL_IMMORTAL ) )
act_comm.c:		if ( ( IS_SET( vch->in_room->area->area_flags, AREA_MUDSCHOOL ) ) 
act_comm.c:		   && ( vch->level < LEVEL_IMMORTAL ) )
act_comm.c:	    if ( ( IS_SET( ch->in_room->area->area_flags, AREA_MUDSCHOOL ) ) 
act_comm.c:		 && ( ch->level < LEVEL_IMMORTAL ) )
act_comm.c:		if ( ( !IS_SET( vch->in_room->area->area_flags, AREA_MUDSCHOOL ) )
act_comm.c:		   && ( vch->level < LEVEL_IMMORTAL ) )
act_comm.c:	    position		= vch->position;
act_comm.c:		vch->position	= POS_STANDING;
act_comm.c:/*                     if ( vch->trust > 111 )
act_comm.c:	    vch->position	= position;
act_comm.c:  if(ch->guild == NULL)
act_comm.c:  if(ch->clan == 0)
act_comm.c:      REMOVE_BIT(ch->deaf, CHANNEL_AUCTION);
act_comm.c:	REMOVE_BIT( ch->deaf, CHANNEL_AUCTION );
act_comm.c:  if ( ( (ch->money.gold*C_PER_G) + (ch->money.silver*S_PER_G) +
act_comm.c:         (ch->money.copper) ) < ( (amt.gold*C_PER_G) + (amt.silver*S_PER_G) +
act_comm.c:  REMOVE_BIT(ch->deaf, CHANNEL_AUCTION);
act_comm.c:  if ( ch->gold < bid )
act_comm.c:  REMOVE_BIT(ch->deaf, CHANNEL_AUCTION);
act_comm.c:    if ( !IS_NPC( ch ) && ch->level < LEVEL_HERO )
act_comm.c:    if ( !IS_NPC( ch ) && ( ch->level < 4 ) && 
act_comm.c:       ( IS_SET( ch->in_room->area->area_flags, AREA_MUDSCHOOL ) ) )
act_comm.c:    if ( !IS_NPC( ch ) && (   IS_SET( ch->act, PLR_SILENCE )
act_comm.c:			   || IS_SET( ch->act, PLR_NO_TELL ) ) )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENT ) )
act_comm.c:	|| ( IS_NPC( victim ) && victim->in_room != ch->in_room ) ) */
act_comm.c:              && victim->in_room != ch->in_room           ) )
act_comm.c:    if ( !IS_NPC( ch ) && (   IS_SET( ch->act, PLR_SILENCE )
act_comm.c:			   || IS_SET( ch->act, PLR_NO_TELL ) ) )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENT ) )
act_comm.c:	|| ( IS_NPC( victim ) && victim->in_room != ch->in_room ) )
act_comm.c:    if ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_SILENCE ) )
act_comm.c:    if ( !( victim = ch->reply ) )
act_comm.c:    if ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_NO_EMOTE ) )
act_comm.c:    level = UMIN( ch->level,
act_comm.c:    act( pose_table[pose].message[2*ch->class+0], ch, NULL, NULL, TO_CHAR );
act_comm.c:    act( pose_table[pose].message[2*ch->class+1], ch, NULL, NULL, TO_ROOM );
act_comm.c:    if ( ch->position == POS_FIGHTING )
act_comm.c:    if ( ch->position  < POS_STUNNED  )
act_comm.c:    if ( ch->combat_timer )
act_comm.c:    if ( ch->in_room->vnum == ROOM_VNUM_SMITHY )
act_comm.c:    if ( ch->questobj )
act_comm.c:    if ( ch->questobj->carried_by == ch )
act_comm.c:       extract_obj( ch->questobj ); /* if on char extract */
act_comm.c:       ch->questobj->timer = 1; /* Let obj_update extract it - Hann */
act_comm.c:        if(wch->level >= LEVEL_IMMORTAL) immcount++;
act_comm.c:    if ( (ch->money.gold > 500000) ||
act_comm.c:	 (ch->money.silver/SILVER_PER_GOLD > 500000) ||
act_comm.c:         (ch->money.copper/COPPER_PER_GOLD > 500000) )
act_comm.c:       tax.gold   = (ch->money.gold > 500000) ? ch->money.gold * 0.15 : 0;
act_comm.c:       tax.silver = (ch->money.silver/SILVER_PER_GOLD > 500000) ?
act_comm.c:		     ch->money.silver * 0.15 : 0;
act_comm.c:       tax.copper = (ch->money.copper/COPPER_PER_GOLD > 500000) ?
act_comm.c:		     ch->money.copper * 0.15 : 0;
act_comm.c:       sub_money( &ch->money, &tax );
act_comm.c:    if ( ch->gold > 500000 )
act_comm.c:       tax = ch->gold * 0.15 ;
act_comm.c:       ch->gold -= tax;
act_comm.c:    if ( IS_SET( ch->act2, PLR2_SOUND ))
act_comm.c:    if ( !IS_SET( ch->act, PLR_WIZINVIS ) && !IS_AFFECTED2(ch, AFF_PLOADED) )
act_comm.c:          info( "%s has left the realms.", (int)(ch->name), 0 );
act_comm.c:       for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
act_comm.c:          if ( get_trust(gch) >= ch->wizinvis )
act_comm.c:       REMOVE_BIT( ch->affected_by2, AFF_PLOADED );
act_comm.c:    if (ch->level != L_IMP)
act_comm.c:       sprintf(log_buf,"%s has quit in room vnum %d.", ch->name, ch->in_room->vnum);
act_comm.c:    if ( IS_SET( ch->act, PLR_QUEST ) )
act_comm.c:       REMOVE_BIT( ch->act, PLR_QUEST );
act_comm.c:    if ( IS_SET( ch->act, PLR_QUESTOR ) );
act_comm.c:       REMOVE_BIT( ch->act, PLR_QUESTOR );
act_comm.c:	     add_money( &ch->money, &auc_cost );
act_comm.c:       ch->gold += auc_cost;
act_comm.c:    for ( PeT = ch->in_room->people; PeT; PeT = PeT->next_in_room )
act_comm.c:    if (ch->pcdata->in_progress)
act_comm.c:       free_note (ch->pcdata->in_progress);
act_comm.c:    d = ch->desc;
act_comm.c:    if (ch->desc != NULL) 
act_comm.c:       d->host = str_dup(ch->pcdata->host);
act_comm.c:  if ( !ch->desc )
act_comm.c:  if ( str_cmp(ch->desc->incomm, "delete yes") )
act_comm.c:  if ( ch->desc->original || IS_NPC(ch) )
act_comm.c:  info( "%s is no more.", (int)(ch->name), 0 );
act_comm.c:  sprintf(log_buf, "%s has DELETED in room vnum %d.", ch->name,
act_comm.c:      ch->in_room->vnum);
act_comm.c:        add_money( &ch->money, &auc_cost );
act_comm.c:        ch->gold += auc_cost;
act_comm.c:  sprintf(log_buf, "rm -f %s%c/%s", PLAYER_DIR, LOWER(ch->name[0]),
act_comm.c:      capitalize(ch->name));
act_comm.c:  sprintf(log_buf, "rm %s%c/%s.cps", PLAYER_DIR, LOWER(ch->name[0]),
act_comm.c:      capitalize(ch->name));
act_comm.c:  delete_playerlist( ch->name );
act_comm.c:  d = ch->desc;
act_comm.c:    if ( ch->level < 2 )
act_comm.c:    if ( IS_AFFECTED( ch, AFF_CHARM ) && ch->master )
act_comm.c:	act( "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
act_comm.c:	if ( !ch->master )
act_comm.c:    if ( ( ch->level - victim->level < -8
act_comm.c:	  || ch->level - victim->level >  8 )
act_comm.c:    if ( ch->master )
act_comm.c:    if ( ch->master )
act_comm.c:    ch->master        = master;
act_comm.c:    ch->leader        = NULL;
act_comm.c:    if ( !ch->master )
act_comm.c:	REMOVE_BIT( ch->affected_by, AFF_CHARM );
act_comm.c:    if ( can_see( ch->master, ch ) )
act_comm.c:	    ch, NULL, ch->master, TO_VICT );
act_comm.c:	ch, NULL, ch->master, TO_CHAR );
act_comm.c:    ch->master = NULL;
act_comm.c:    ch->leader = NULL;
act_comm.c:    if ( ch->master )
act_comm.c:    ch->leader = NULL;
act_comm.c:    for ( fch = char_list; fch; fch = fch->next )
act_comm.c:        if ( fch->deleted )
act_comm.c:	if ( fch->master == ch )
act_comm.c:	if ( fch->leader == ch )
act_comm.c:	    fch->leader = NULL;
act_comm.c:    for ( och = ch->in_room->people; och; och = och_next )
act_comm.c:        och_next = och->next_in_room;
act_comm.c:        if ( och->deleted )
act_comm.c:	  if ( IS_SET( och->act, ACT_NEWBIE ) )
act_comm.c:	    && och->master == ch 
act_comm.c:	leader = ( ch->leader ) ? ch->leader : ch;
act_comm.c:	for ( gch = char_list; gch; gch = gch->next )
act_comm.c:	    if ( gch->deleted )
act_comm.c:			gch->level,
act_comm.c:			gch->hit,   MAX_HIT( gch ),
act_comm.c:			gch->move,  MAX_MOVE(gch),
act_comm.c:			gch->exp );
act_comm.c:			gch->level,
act_comm.c:			gch->hit,   MAX_HIT( gch ),
act_comm.c:			gch->mana,  MAX_MANA(gch),
act_comm.c:			gch->move,  MAX_MOVE(gch),
act_comm.c:			gch->exp );
act_comm.c:			gch->level,
act_comm.c:			gch->hit,   MAX_HIT( gch ),
act_comm.c:			gch->bp,    MAX_BP( gch ),
act_comm.c:			gch->move,  MAX_MOVE(gch),
act_comm.c:			gch->exp );
act_comm.c:                if ( gch->gspell && gch->gspell->timer > 0 )
act_comm.c:    if ( ch->master || ( ch->leader && ch->leader != ch ) )
act_comm.c:    if (   ch->level - victim->level < -8
act_comm.c:	|| ch->level - victim->level >  8 )
act_comm.c:    if ( ( ch->money.gold < amt.gold ) || ( ch->money.silver < amt.silver )
act_comm.c:	|| ( ch->money.copper < amt.copper ) )
act_comm.c:    if ( ch->gold < amount )
act_comm.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
act_comm.c:        if ( gch->deleted )
act_comm.c:      ch->money.gold -= amount;
act_comm.c:      ch->money.gold += share + extra;
act_comm.c:      ch->money.silver -= amount;
act_comm.c:      ch->money.silver += share + extra;
act_comm.c:      ch->money.copper -= amount;
act_comm.c:      ch->money.silver += share + extra;
act_comm.c:    ch->gold -= amount;
act_comm.c:    ch->gold += share + extra;
act_comm.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
act_comm.c:        if ( gch->deleted )
act_comm.c:	    gch->money.gold   += ( !str_cmp( arg2, "gold" ) ) ?
act_comm.c:	    gch->money.silver += ( !str_cmp( arg2, "silver" ) ) ?
act_comm.c:	    gch->money.copper += ( !str_cmp( arg2, "copper" ) ) ?
act_comm.c:	    gch->gold += share;
act_comm.c:    if ( IS_SET( ch->act, PLR_NO_TELL ) )
act_comm.c:    sprintf( buf, "%s tells the group '%s'.\n\r", ch->name, argument );
act_comm.c:    for ( gch = char_list; gch; gch = gch->next )
act_comm.c:        if ( gch->deleted )
act_comm.c:    if ( ach->deleted || bch->deleted )
act_comm.c:    if ( ach->leader ) ach = ach->leader;
act_comm.c:    if ( bch->leader ) bch = bch->leader;
act_comm.c:    if ( ach->deleted || bch->deleted )
act_comm.c:    ch->alignment += 10;
act_comm.c:  else if (!IS_NPC(ch) && ch->pcdata->learned[gsn_prayer] < number_percent( ))
act_comm.c:    ch->money.gold += 1;
act_comm.c:    ch->gold++;
act_comm.c:    af.duration = ch->level / 3;
act_comm.c:    af.level = ch->level;
act_comm.c:    af.modifier = number_range( ch->level, ch->level * 2 );
act_comm.c:    af.modifier = number_range( ch->level / 2, ch->level );
act_comm.c:    af.modifier = ((ch->level - 1) / 50) + 1;
act_comm.c:    ch->alignment -= 10;
act_comm.c:    for ( helper = ch->in_room->people; helper; helper = helper->next_in_room )
act_comm.c:	if( !IS_SET( ch->act, PLR_COLOUR ) )
act_comm.c:	    SET_BIT( ch->act, PLR_COLOUR );
act_comm.c:	    REMOVE_BIT( ch->act, PLR_COLOUR );
act_comm.c:	|| (IS_NPC(victim) && victim->in_room != ch->in_room)) {
act_comm.c:	send_to_char(ch->pcdata->ignore, ch);
act_comm.c:    strcpy(buf, ch->pcdata->ignore);
act_comm.c:              || ( IS_NPC(victim) && victim->in_room != ch->in_room ) )
act_comm.c:	free_string(ch->pcdata->ignore);
act_comm.c:	ch->pcdata->ignore = str_dup(buf);
act_comm.c:	    free_string(ch->pcdata->ignore);
act_comm.c:	    ch->pcdata->ignore = str_dup(buf2);
act_comm.c:     if (is_name(ch, victim->name, ch->pcdata->ignore))
act_info.c:    if (!ch->desc)
act_info.c:	    if (IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE)) {
act_info.c:	if (IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE)) {
act_info.c:	if (IS_NPC(ch) || IS_SET(ch->act, PLR_COMBINE))
act_info.c:    if (IS_NPC(victim) && ch->questmob && victim == ch->questmob)
act_info.c:	if (!IS_NPC(victim) && !IS_SET(ch->act, PLR_BRIEF))
act_info.c:	&& (number_percent() < ch->pcdata->learned[gsn_peek] || (ch->race == RACE_HALFLING))) {
act_info.c:    for (rch = list; rch; rch = rch->next_in_room) {
act_info.c:	if (rch->deleted || rch == ch)
act_info.c:	if (!(rch->desc)
act_info.c:	    && IS_SET(rch->act, PLR_WIZINVIS)
act_info.c:	    && get_trust(ch) < rch->wizinvis)
act_info.c:	} else if (room_is_dark(ch->in_room)
act_info.c:    if (!IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT))
act_info.c:    if (IS_AFFECTED(ch, AFF_BLIND) && ch->race != RACE_ILLITHID) {
act_info.c:    if (!IS_NPC(ch) && !ch->desc)
act_info.c:    if (ch->position < POS_SLEEPING) {
act_info.c:    if (ch->position == POS_SLEEPING) {
act_info.c:    if (is_raffected(ch->in_room, gsn_globedark)
act_info.c:	&& !IS_SET(ch->act, PLR_HOLYLIGHT)
act_info.c:	&& ch->race != RACE_DROW) {
act_info.c:	&& !IS_SET(ch->act, PLR_HOLYLIGHT)
act_info.c:	&& room_is_dark(ch->in_room)
act_info.c:	&& (ch->race != RACE_ELF)
act_info.c:	&& (ch->race != RACE_DWARF)
act_info.c:	&& (ch->race != RACE_DROW)
act_info.c:	&& (ch->race != RACE_DEMON)
act_info.c:	&& (ch->race != RACE_TABAXI)) {
act_info.c:	show_char_to_char(ch->in_room->people, ch);
act_info.c:	send_to_char(ch->in_room->name, ch);
act_info.c:	if (IS_IMMORTAL(ch) && (!IS_NPC(ch) || IS_SET(ch->act, PLR_HOLYLIGHT))) {
act_info.c:	    sprintf(buf, " {Y[{MRoom %d{Y]{x", ch->in_room->vnum);
act_info.c:	   if ( !IS_NPC( ch ) && IS_SET( ch->act, PLR_AUTOEXIT ) )
act_info.c:	    || (!IS_NPC(ch) && !IS_SET(ch->act, PLR_BRIEF))) {
act_info.c:	    send_to_char(ch->in_room->description, ch);
act_info.c:	if (!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT))
act_info.c:	show_list_to_char(ch->in_room->contents, ch, FALSE, FALSE);
act_info.c:	show_char_to_char(ch->in_room->people, ch);
act_info.c:		for (obj = ch->carrying; obj; obj = obj->next) {
act_info.c:		|| (!IS_NPC(ch) && !IS_SET(ch->act, PLR_BRIEF)))
act_info.c:    for (obj = ch->carrying; obj; obj = obj->next_content) {
act_info.c:    for (obj = ch->in_room->contents; obj; obj = obj->next_content) {
act_info.c:    pdesc = get_extra_descr(ch, arg1, ch->in_room->extra_descr);
act_info.c:		    arena.cch->name, arena.cch->level,
act_info.c:			arena.och->name, arena.och->level,
act_info.c:	    fp = (arena.fch->hit * 100) / MAX_HIT(arena.fch);
act_info.c:	    sp = (arena.sch->hit * 100) / MAX_HIT(arena.sch);
act_info.c:		    arena.fch->name, arena.fch->level,
act_info.c:		    arena.sch->name, arena.sch->level,
act_info.c:			arena.fch->name);
act_info.c:			arena.sch->name);
act_info.c:    if (!(pexit = ch->in_room->exit[door]) || !pexit->to_room) {
act_info.c:	if (IS_SET(ch->in_room->room_flags, ROOM_NO_MAGIC)
act_info.c:   || ( !IS_NPC( ch ) && !IS_SET( ch->act, PLR_BRIEF ) ) )
act_info.c:	rid = ch->in_room;
act_info.c:	ch->in_room = pexit->to_room;
act_info.c:	ch->in_room = rid;
act_info.c:	eprog_scry_trigger(pexit, ch->in_room, ch);
act_info.c:    eprog_look_trigger(pexit, ch->in_room, ch);
act_info.c:	if ((pexit = ch->in_room->exit[door])
act_info.c:	sprintf(buf, "Bamfin: %s %s.\n\r", ch->name, ch->pcdata->bamfin);
act_info.c:	sprintf(buf, "Bamfout: %s %s.\n\r", ch->name, ch->pcdata->bamfout);
act_info.c:	sprintf(buf, "Bamfusee: You %s.\n\r", ch->pcdata->bamfusee);
act_info.c:	sprintf(buf, "Transto: Victim %s.\n\r", ch->pcdata->transto);
act_info.c:	sprintf(buf, "Transfrom: Victim %s.\n\r", ch->pcdata->transfrom);
act_info.c:	sprintf(buf, "Transvict: %s %s.\n\r", ch->name, ch->pcdata->transvict);
act_info.c:	sprintf(buf, "Slayusee: You %s.\n\r", ch->pcdata->slayusee);
act_info.c:	sprintf(buf, "Slayroom: %s %s.\n\r", ch->name, ch->pcdata->slayroom);
act_info.c:	sprintf(buf, "Slayvict: %s %s.\n\r", ch->name, ch->pcdata->slayvict);
act_info.c:    for (counter = 1; counter < ((40 - strlen(ch->name)) / 2); counter++)
act_info.c:    strcat(buf, ch->name);
act_info.c:    for (counter = 1; counter < ((40 - strlen(ch->name)) / 2); counter++)
act_info.c:    if ((40 - strlen(ch->name)) % 2 == 1)
act_info.c:	    IS_NPC(ch) ? "" : strip_color(ch->pcdata->title));
act_info.c:	if (IS_SET(ch->act, PLR_HOLYLIGHT))
act_info.c:		ch->wizinvis, ch->cloaked);
act_info.c:	    ch->level,
act_info.c:	    (ch->played + (int) (current_time - ch->logon)) / 3600);
act_info.c:	    (get_race_data(ch->race))->race_full, IS_NPC(ch) ? "mobile" : class_long(ch),
act_info.c:	    ch->sex == 0 ? "neuter" : ch->sex == 1 ? "male" : "female");
act_info.c:    ch->hit, MAX_HIT(ch), ch->mana, MAX_MANA(ch), ch->move, MAX_MOVE(ch));
act_info.c:    if (ch->level >= 151)
act_info.c:	tnldata = (xp_tolvl(ch) - ch->exp);
act_info.c:	    ch->practice, ch->exp, tnldata);
act_info.c:	    GET_HITROLL(ch), GET_DAMROLL(ch), ch->wimpy);
act_info.c:	    ch->money.gold, ch->money.silver, ch->money.copper);
act_info.c:    if (ch->alignment == 1000)
act_info.c:    else if (ch->alignment == 750)
act_info.c:    else if (ch->alignment == 500)
act_info.c:    else if (ch->alignment == 250)
act_info.c:    else if (ch->alignment == 0)
act_info.c:    else if (ch->alignment == -250)
act_info.c:    else if (ch->alignment == -500)
act_info.c:    else if (ch->alignment == -750)
act_info.c:    else if (ch->alignment == -1000)
act_info.c:    switch (ch->position) {
act_info.c:    sprintf(buf, " {RQpts  :{x {C%-6d{R       |\n\r", ch->questpoints);
act_info.c:	    ch->carry_number, can_carry_n(ch),
act_info.c:	    ch->carry_weight, can_carry_w(ch));
act_info.c:	    IS_NPC(ch) ? 13 : ch->pcdata->perm_str, IS_NPC(ch) ? 13 : get_curr_str(ch),
act_info.c:	    IS_NPC(ch) ? 13 : ch->pcdata->perm_dex, IS_NPC(ch) ? 13 : get_curr_dex(ch),
act_info.c:	    IS_NPC(ch) ? 13 : ch->pcdata->perm_int, IS_NPC(ch) ? 13 : get_curr_int(ch),
act_info.c:	    IS_NPC(ch) ? 13 : ch->pcdata->perm_wis, IS_NPC(ch) ? 13 : get_curr_wis(ch));
act_info.c:	    IS_NPC(ch) ? 13 : ch->pcdata->perm_con, IS_NPC(ch) ? 13 : get_curr_con(ch),
act_info.c:	    IS_NPC(ch) ? 20 : ch->charisma);
act_info.c:	if (ch->pcdata->empowerments && *ch->pcdata->empowerments)
act_info.c:		    ch->pcdata->empowerments);
act_info.c:	if (ch->pcdata->detractments && *ch->pcdata->detractments)
act_info.c:		    ch->pcdata->detractments);
act_info.c:    if (!ch->affected && !ch->affected2) {
act_info.c:    if (ch->affected) {
act_info.c:	for (paf = ch->affected; paf; paf = paf->next) {
act_info.c:	    if (ch->level >= 20) {
act_info.c:    if (ch->affected2) {
act_info.c:	for (paf = ch->affected2; paf; paf = paf->next) {
act_info.c:	    if (ch->level >= 20) {
act_info.c:	if (wch->level < iLevelLower
act_info.c:	    || wch->level > iLevelUpper
act_info.c:	    || (fImmortalOnly && wch->level < LEVEL_IMMORTAL)
act_info.c:	    || (fHeroOnly && wch->level < LEVEL_HERO)
act_info.c:	    || (fHeroOnly && wch->level > L_CHAMP5)
act_info.c:	    || (fRaceRestrict && !rgfRace[wch->race])
act_info.c:	    || (fNameRestrict && str_prefix(arg1, wch->name))
act_info.c:/*          || ( fGuildRestrict && str_cmp( wch->guild->name,
act_info.c:	    || (fClanRestrict && !rgfClan[wch->clan]))
act_info.c:	sprintf(lvl,"%d", wch->level);
act_info.c:	if (wch->level < LEVEL_IMMORTAL)
act_info.c:	if (wch->level >= LEVEL_IMMORTAL)
act_info.c:	if (wch->level >= LEVEL_HERO)
act_info.c:	    switch (wch->level) {
act_info.c:		class = wch->sex == 2 ? "{MSTORM LADY{x"
act_info.c:		class = wch->sex == 2 ? "GODDESS"
act_info.c:		    class = wch->sex == 2 ? "{CMATRIARCH{x"
act_info.c:		    class = wch->sex == 2 ? "{gLADYRANGER{x"
act_info.c:	if (wch->level >= L_APP
act_info.c:	    && wch->pcdata->whotype
act_info.c:	    && str_cmp(wch->pcdata->whotype, "!!!!!!!!!!!!"))
act_info.c:	    class = wch->pcdata->whotype;
act_info.c:	race = (get_race_data(wch->race))->race_name;
act_info.c:	if (wch->clan != 0) {
act_info.c:	    pClan = get_clan_index(wch->clan);
act_info.c:		switch (wch->clev) {
act_info.c:		switch (wch->clev) {
act_info.c:	if (wch->level < LEVEL_HERO) {
act_info.c:	} else if (wch->level >= LEVEL_HERO
act_info.c:		   && wch->pcdata->whotype
act_info.c:		   && !strcmp(class, wch->pcdata->whotype)) {
act_info.c:		    wch->pcdata->whotype);
act_info.c:	if (IS_SET(wch->act, PLR_QUEST)) {
act_info.c:	if (IS_SET(wch->act, PLR_QUESTOR))
act_info.c:	if (wch->guild != NULL) {
act_info.c:	    sprintf(buf + strlen(buf), "[%s", wch->guild->name);
act_info.c:	    switch (wch->guild_rank) {
act_info.c:		sprintf(buf + strlen(buf), " %s] ", wch->sex == SEX_FEMALE ?
act_info.c:			wch->sex == SEX_FEMALE ? "Lady" : "Lord");
act_info.c:			wch->sex == SEX_FEMALE ? "lady" : "lord");
act_info.c:	if (wch->desc && wch->desc->editor != 0) {
act_info.c:	    if (wch->desc->editor == 13)	/* forging eq */
act_info.c:	if (wch->pcdata->lname)
act_info.c:		    lvl, wch->name, (wch->pcdata->lname[0] != '\0') ? " " : "",
act_info.c:/*        wch->name, ( *wch->pcdata->lname != 39 ) ? " " : "",  */
act_info.c:		    wch->pcdata->lname, wch->pcdata->title);
act_info.c:		    IS_SET(wch->act, PLR_PKILLER) ? "K" : " ",
act_info.c:	    /*  IS_SET(wch->act, PLR_SOUND) ? "S" : " ", */
act_info.c:		    lvl, IS_SET(wch->act, PLR_AFK) ? "{W<{YAFK{W>{x" : "",
act_info.c:		  IS_SET(wch->act, PLR_WIZINVIS) ? "{W({RWizi{W){x" : "",
act_info.c:		IS_SET(wch->act, PLR_CLOAKED) ? "{W({RCloaked{W){x" : "",
act_info.c:		    wch->name, wch->pcdata->title);
act_info.c:	if (wch->clan != 0)
act_info.c:	if (wch->clan != 0) {
act_info.c:	    pClan = get_clan_index(wch->clan);
act_info.c:	if (fNameRestrict && !str_cmp(arg1, wch->name))
act_info.c:	if (wch->level < iLevelLower
act_info.c:	    || wch->level > iLevelUpper
act_info.c:	    || (fImmortalOnly && wch->level < LEVEL_IMMORTAL)
act_info.c:	    || (fHeroOnly && wch->level < LEVEL_HERO)
act_info.c:	    || (fHeroOnly && wch->level > L_CHAMP5)
act_info.c:	    || (fRaceRestrict && !rgfRace[wch->race])
act_info.c:	    || (fNameRestrict && str_prefix(arg1, wch->name))
act_info.c:/*          || ( fGuildRestrict && str_cmp( wch->guild->name,
act_info.c:	    || (fClanRestrict && !rgfClan[wch->clan]))
act_info.c:	if (wch->level >= LEVEL_IMMORTAL)
act_info.c:	if (wch->level >= LEVEL_HERO)
act_info.c:	    switch (wch->level) {
act_info.c:		class = wch->sex == 2 ? "STORM LADY" : "STORM LORD";
act_info.c:		class = wch->sex == 2 ? "GODDESS" : "GOD";
act_info.c:		    class = wch->sex == 2 ? "MATRIARCH" : "PATRIARCH";
act_info.c:		    class = wch->sex == 2 ? "LADYRANGER" : "LORDRANGER";
act_info.c:	if (wch->level >= L_APP
act_info.c:	    && wch->pcdata->whotype
act_info.c:	    && str_cmp(wch->pcdata->whotype, "!!!!!!!!!!!!"))
act_info.c:	    class = wch->pcdata->whotype;
act_info.c:	race = (get_race_data(wch->race))->race_name;
act_info.c:	if (wch->clan != 0) {
act_info.c:	    pClan = get_clan_index(wch->clan);
act_info.c:		switch (wch->clev) {
act_info.c:		switch (wch->clev) {
act_info.c:	if (wch->level < LEVEL_HERO) {
act_info.c:	} else if (wch->level >= LEVEL_HERO
act_info.c:		   && wch->pcdata->whotype
act_info.c:		   && !strcmp(class, wch->pcdata->whotype)) {
act_info.c:	    int len = strlen_wo_col(wch->pcdata->whotype);
act_info.c:	if (IS_SET(wch->act, PLR_QUEST)) {
act_info.c:	if (IS_SET(wch->act, PLR_QUESTOR))
act_info.c:	if (wch->guild != NULL) {
act_info.c:	    sprintf(buf + strlen(buf), "[%s", wch->guild->name);
act_info.c:	    switch (wch->guild_rank) {
act_info.c:		sprintf(buf + strlen(buf), " %s] ", wch->sex == SEX_FEMALE ?
act_info.c:			wch->sex == SEX_FEMALE ? "Lady" : "Lord");
act_info.c:			wch->sex == SEX_FEMALE ? "lady" : "lord");
act_info.c:	if (IS_SET(wch->act, PLR_AFK))
act_info.c:	if (IS_SET(wch->act, PLR_PKILLER))
act_info.c:	if (IS_SET(wch->act, PLR_WIZINVIS)) {
act_info.c:	    sprintf(buf, "%s %d%s", "{M(Wizinvis", wch->wizinvis, "){x ");
act_info.c:	if (IS_SET(wch->act, PLR_CLOAKED)) {
act_info.c:	    sprintf(buf, "%s %d%s", "{C(Cloaked", wch->cloaked, ") {x");
act_info.c:	if (wch->desc && wch->desc->editor != 0) {
act_info.c:	    if (wch->desc->editor == 13)	/* forging eq */
act_info.c:	if (IS_SET(wch->act, PLR_THIEF))
act_info.c:	if (wch->pcdata->lname)
act_info.c:		    wch->name, (wch->pcdata->lname[0] != '\0') ? " " : "",
act_info.c:/*        wch->name, ( *wch->pcdata->lname != 39 ) ? " " : "",  */
act_info.c:		    wch->pcdata->lname, wch->pcdata->title);
act_info.c:		    wch->name, wch->pcdata->title);
act_info.c:	if (wch->clan != 0)
act_info.c:	if (wch->clan != 0) {
act_info.c:	    pClan = get_clan_index(wch->clan);
act_info.c:	if (fNameRestrict && !str_cmp(arg1, wch->name))
act_info.c:   if( str_prefix( name, wch->name ) )
act_info.c:   class = class_table[ wch->class ].who_name;
act_info.c:   if( wch->level >= LEVEL_HERO )
act_info.c:   switch( wch->level )
act_info.c:   if ( wch->sex == 2 )
act_info.c:   race = (get_race_data(wch->race))->race_name;    
act_info.c:   if (wch->clan != 0)
act_info.c:   pClan = get_clan_index(wch->clan);
act_info.c:   switch ( wch->clev )
act_info.c:   switch ( wch->clev )
act_info.c:   if ( wch->level < LEVEL_HERO )
act_info.c:   wch->level, race, class );
act_info.c:   if(wch->guild != NULL)
act_info.c:   sprintf(buf+strlen(buf), "[%s", wch->guild->name);
act_info.c:   switch(wch->guild_rank)
act_info.c:   if ( wch->pcdata->lname )
act_info.c:   wch->name, ( wch->pcdata->lname[0] != '\0' ) ? " " : "", 
act_info.c:   wch->pcdata->lname, wch->pcdata->title );
act_info.c:   wch->name, wch->pcdata->title );
act_info.c:   if (wch->clan != 0)
act_info.c:    show_list_to_char(ch->carrying, ch, TRUE, TRUE);
act_info.c:			&& ch->pcdata->learned[gsn_dualclaw] > 0))) {
act_info.c:			 && ch->pcdata->learned[gsn_blackbelt] > 0))) {
act_info.c:	for (obj2 = ch->carrying; obj2; obj2 = obj2->next_content) {
act_info.c:		&& (victim->in_room->area == ch->in_room->area
act_info.c:		    || ch->level >= LEVEL_IMMORTAL)
act_info.c:		if (ch->level >= LEVEL_IMMORTAL)
act_info.c:		  || victim->race == RACE_HALFLING) && ch->level < LEVEL_IMMORTAL)
act_info.c:		|| ((ch->level >= LEVEL_IMMORTAL) && (!victim->in_room)))
act_info.c:	    if (((victim->in_room->area == ch->in_room->area)
act_info.c:		 || (ch->level >= LEVEL_IMMORTAL))
act_info.c:		if (ch->level >= LEVEL_IMMORTAL)
act_info.c:    diff = victim->level - ch->level;
act_info.c:    hpdiff = (ch->hit - victim->hit);
act_info.c:	free_string(ch->pcdata->title);
act_info.c:	ch->pcdata->title = str_dup(" ");
act_info.c:    free_string(ch->pcdata->title);
act_info.c:    ch->pcdata->title = str_dup(buf);
act_info.c:   if ( ch->description )
act_info.c:   strcat( buf, ch->description );
act_info.c:   free_string( ch->description );
act_info.c:   ch->description = str_dup( buf );
act_info.c:    string_append(ch, &ch->description);
act_info.c:   send_to_char( ch->description ? ch->description : "(None).\n\r", ch ); */
act_info.c:		ch->hit, MAX_HIT(ch),
act_info.c:		ch->mana, MAX_MANA(ch),
act_info.c:		ch->move, MAX_MOVE(ch),
act_info.c:		ch->exp);
act_info.c:		ch->hit, MAX_HIT(ch),
act_info.c:		ch->bp, MAX_BP(ch),
act_info.c:		ch->move, MAX_MOVE(ch),
act_info.c:		ch->exp);
act_info.c:		ch->hit, MAX_HIT(ch),
act_info.c:		ch->mana, MAX_MANA(ch),
act_info.c:		ch->move, MAX_MOVE(ch),
act_info.c:		ch->exp);
act_info.c:		ch->hit, MAX_HIT(ch),
act_info.c:		ch->bp, MAX_BP(ch),
act_info.c:		ch->move, MAX_MOVE(ch),
act_info.c:		ch->exp);
act_info.c:    if (ch->level < 3) {
act_info.c:	for (mob = ch->in_room->people; mob; mob = mob->next_in_room) {
act_info.c:	    if ((mob) || (ch->pcdata->learned[sn] > 0)) {
act_info.c:			skill_table[sn].name, ch->pcdata->learned[sn]);
act_info.c:		ch->practice);
act_info.c:	for (mob = ch->in_room->people; mob; mob = mob->next_in_room) {
act_info.c:	if (ch->practice <= 0) {
act_info.c:	if (IS_NPC(ch) || ch->pcdata->learned[sn] > 35) {
act_info.c:	if (ch->pcdata->learned[sn] >= adept) {
act_info.c:	    ch->practice--;
act_info.c:	    ch->pcdata->learned[sn] += int_app[get_curr_int(ch)].learn;
act_info.c:/*          ch->pcdata->learned[sn] += ( ( get_curr_int( ch ) * 4 ) / 3 ); */
act_info.c:	    if (ch->pcdata->learned[sn] < adept) {
act_info.c:		ch->pcdata->learned[sn] = adept;
act_info.c:    ch->wimpy = wimpy;
act_info.c:    if (strcmp(crypt(arg1, ch->pcdata->pwd), ch->pcdata->pwd)) {
act_info.c:    pwdnew = crypt(arg2, ch->name);
act_info.c:    free_string(ch->pcdata->pwd);
act_info.c:    ch->pcdata->pwd = str_dup(pwdnew);
act_info.c:	if (!IS_NPC(ch) && IS_SET(ch->act, PLR_SILENCE)) {
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_AUCTION)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_CHAT)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_OOC)
act_info.c: 	send_to_char(!IS_SET(ch->deaf, CHANNEL_QUOTE)
act_info.c: 	send_to_char(!IS_SET(ch->deaf, CHANNEL_GRATZ)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_CLASS)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_CLAN)
act_info.c:/*      if( ch->level > 2 )
act_info.c:   send_to_char( !IS_SET( ch->deaf, CHANNEL_VENT )
act_info.c:	    send_to_char(!IS_SET(ch->deaf, CHANNEL_HERO)
act_info.c:	    send_to_char(!IS_SET(ch->deaf, CHANNEL_IMMTALK)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_MUSIC)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_QUESTION)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_GOSSIP)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_YELL)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_INFO)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_CHALLENGE)
act_info.c:	send_to_char(!IS_SET(ch->deaf, CHANNEL_ARENA)
act_info.c:	    send_to_char(!IS_SET(ch->deaf, CHANNEL_LOG)
act_info.c:	    send_to_char(!IS_SET(ch->deaf, CHANNEL_BUILD)
act_info.c:	    send_to_char(!IS_SET(ch->deaf, CHANNEL_GOD)
act_info.c:	    send_to_char(!IS_SET(ch->deaf, CHANNEL_CLASS_MASTER)
act_info.c:	    send_to_char(!IS_SET(ch->deaf, CHANNEL_CLAN_MASTER)
act_info.c:	    send_to_char(!IS_SET(ch->deaf, CHANNEL_GUILD_MASTER)
act_info.c:	    REMOVE_BIT(ch->deaf, bit);
act_info.c:	    SET_BIT(ch->deaf, bit);
act_info.c:	send_to_char(IS_SET(ch->act, PLR_AUTOEXIT)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_AUTOCOINS)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_AUTOSPLIT)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_AUTOLOOT)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_AUTOSAC)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_BLANK)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_BRIEF)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_FULLNAME)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_COMBINE)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_PROMPT)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_TELNET_GA)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_COMBAT)
act_info.c:	send_to_char(IS_SET(ch->act, PLR_SILENCE)
act_info.c:	send_to_char(!IS_SET(ch->act, PLR_NO_EMOTE)
act_info.c:	send_to_char(!IS_SET(ch->act, PLR_NO_TELL)
act_info.c:	    SET_BIT(ch->act, bit);
act_info.c:	    REMOVE_BIT(ch->act, bit);
act_info.c:		(ch->race == RACE_ELF || ch->race == RACE_ELDER)
act_info.c:		&& skill_table[sn].skill_level[ch->class[1]] != level)
act_info.c:		&& skill_table[sn].skill_level[ch->class[1]] != level
act_info.c:		&& skill_table[sn].skill_level[ch->class[2]] != level)
act_info.c:    (IS_SET(ch->act, PLR_AUTOEXIT)
act_info.c:    (IS_SET(ch->act, PLR_AUTOLOOT)
act_info.c:    (IS_SET(ch->act, PLR_AUTOSAC)
act_info.c:    (IS_SET(ch->act, PLR_BLANK)
act_info.c:    (IS_SET(ch->act, PLR_BRIEF)
act_info.c:    (IS_SET(ch->act, PLR_COMBINE)
act_info.c:    (IS_SET(ch->act, PLR_AUTOSPLIT)
act_info.c:    (IS_SET(ch->act, PLR_FULLNAME)
act_info.c:    (IS_SET(ch->act, PLR_COMBAT)
act_info.c:    (IS_SET(ch->act, PLR_TELNET_GA)
act_info.c:    ch->pcdata->pagelen = lines;
act_info.c:    ch = (ch->desc->original ? ch->desc->original : ch->desc->character);
act_info.c:	(IS_SET(ch->act, PLR_PROMPT)
act_info.c:    free_string(ch->prompt);
act_info.c:    ch->prompt = str_dup(buf);
act_info.c:    if (IS_NPC(ch) || number_percent() > ch->pcdata->learned[gsn_grip]) {
act_info.c:    if (ch->position == POS_FIGHTING || is_affected(ch, gsn_grip))
act_info.c:    af.level = ch->level;
act_info.c:    af.duration = ch->level / 6;
act_info.c:    af.modifier = ch->level - (ch->level / 4);
act_info.c:    pClan = get_clan_index(ch->clan);
act_info.c:    if ((ch->clan == 0)
act_info.c:	|| (ch->clev < 1))
act_info.c:    if (((ch->clev == 1) && (!IS_SET(pClan->settings, CLAN_SECOND_INDUCT)))
act_info.c:    || ((ch->clev == 2) && (!IS_SET(pClan->settings, CLAN_FIRST_INDUCT)))
act_info.c:    || ((ch->clev == 3) && (!IS_SET(pClan->settings, CLAN_LEADER_INDUCT)))
act_info.c:    || ((ch->clev == 4) && (!IS_SET(pClan->settings, CLAN_CHAMP_INDUCT)))
act_info.c:    victim->clan = ch->clan;
act_info.c:    if ((ch->clan == 0)
act_info.c:	|| (ch->clev < 2))
act_info.c:    if ((victim->clan == 0) || (victim->clan != ch->clan))
act_info.c:    pClan = get_clan_index(ch->clan);
act_info.c:    if (ch->clev < 3)
act_info.c:    if ((ch->clan != victim->clan) || (ch->clev < victim->clev))
act_info.c:    if (level > ch->clev) {
act_info.c:    pClan = get_clan_index(ch->clan);
act_info.c:    if (ch->clan != 5) {
act_info.c:    if (ch->ctimer) {
act_info.c:	|| victim->in_room->area != ch->in_room->area) {
act_info.c:    if (ch->level - victim->level > 8 || victim->level - ch->level > 8) {
act_info.c:    ch->ctimer = 5;
act_info.c:    if (ch->guild == NULL) {
act_info.c:    if (!is_name(NULL, ch->name, ch->guild->deity)) {
act_info.c:	&& !strcmp(ch->guild->name, "MERCENARY")) {
act_info.c:    victim->guild = ch->guild;
act_info.c:    if (ch->guild == NULL) {
act_info.c:    if (!is_name(NULL, ch->name, ch->guild->deity)) {
act_info.c:    if (victim->guild != ch->guild) {
act_info.c:    if (ch->guild == NULL) {
act_info.c:    if (!is_name(NULL, ch->name, ch->guild->deity)) {
act_info.c:    if (victim->guild != ch->guild) {
act_info.c:	if (ch->level < qmin) {
act_info.c:	if (ch->level > qmax) {
act_info.c:    if (!(quest) && !IS_SET(ch->act, PLR_QUESTOR)) {
act_info.c:    if (IS_SET(ch->act, PLR_QUEST) && (quest)) {
act_info.c:    } else if (IS_SET(ch->act, PLR_QUEST)) {
act_info.c:	REMOVE_BIT(ch->act, PLR_QUEST);
act_info.c:	SET_BIT(ch->act, PLR_QUEST);
act_info.c:    if (IS_SET(ch->act, PLR_AUTOCOINS)) {
act_info.c:    if (!IS_SET(ch->act, PLR_AUTOCOINS)) {
act_info.c:   switch( ch->arm[limb]->hp )
act_info.c:   ( limb == 1 ) ? "left" : "right", bleedinglev( ch->arm[limb]->bl );
act_info.c:   ( limb == 1 ) ? "left" : "right", bleedinglev( ch->arm[limb]->bl );
act_info.c:   ( limb == 1 ) ? "left" : "right", bleedinglev( ch->arm[limb]->bl );
act_info.c:   ( limb == 1 ) ? "left" : "right", bleedinglev( ch->arm[limb]->bl ); 
act_info.c:   switch( ch->neck->hp )
act_info.c:   bleedinglev( ch->neck->bl ) );
act_info.c:   bleedinglev( ch->neck->bl ) );
act_info.c:   bleedinglev( ch->neck->bl ) );
act_info.c:   bleedinglev( ch->neck->bl ) );
act_info.c:   switch( ch->eyes->hp )
act_info.c:   bleedinglev( ch->eyes->bl ) );
act_info.c:   bleedinglev( ch->eyes->bl ) );
act_info.c:   switch( ch->torso->hp )
act_info.c:   bleedinglev( ch->torso->bl ) );
act_info.c:   bleedinglev( ch->torso->bl ) );
act_info.c:   bleedinglev( ch->torso->bl ) );
act_info.c:   bleedintlev( ch->torso->bl ) );
act_info.c:   switch( ch->leg[limb]->hp )
act_info.c:   ( limb == 1 ) ? "left" : "right", bleedinglev( ch->leg[limb]->bl ) );
act_info.c:   (limb == 1 ) ? "left" : "right", bleedinglev( ch->leg[limb]->bl ) );
act_info.c:   ( limb == 1 ) ? "left" : "right", bleedinglev( ch->leg[limb]->bl ) );
act_info.c:    if (ch->clan != 7) {
act_info.c:    from_room = ch->in_room;
act_info.c:    if (ch->level < L_CHAMP3) {
act_info.c:		" next level.\n\r", ch->exp, xp_tolvl(ch) - ch->exp);
act_info.c:	    get_curr_dex(ch), get_curr_con(ch), ch->charisma);
act_info.c:    sprintf(log_buf, "You are carrying %d gold, %d silver, and %d copper coins.\n\r", ch->money.gold,
act_info.c:	    ch->money.silver, ch->money.copper);
act_info.c:    sprintf(log_buf, "You are currently carrying %d coins.\n\r", ch->gold);
act_info.c:    sprintf(buf, "Last on: %s\n\r", (char *) ctime(&ch->logon));
act_info.c:	sprintf(buf, "Email:%s \n\r", ch->pcdata->email);
act_info.c:	free_string(ch->pcdata->email);
act_info.c:	ch->pcdata->email = str_dup(argument);
act_info.c:	sprintf(buf, "Plan:%s \n\r", ch->pcdata->plan);
act_info.c:	free_string(ch->pcdata->plan);
act_info.c:	ch->pcdata->plan = str_dup(argument);
act_info.c:	    sprintf(buf, "AFK Message: %s\n\r", ch->pcdata->afkchar);
act_info.c:	free_string(ch->pcdata->afkchar);
act_info.c:	ch->pcdata->afkchar = str_dup(argument);
act_info.c:	if (ch->money.gold < amt)
act_info.c:	if (ch->money.silver < amt)
act_info.c:	if (ch->money.copper < amt)
act_info.c:    sub_money(&ch->money, &new_money);
act_info.c:	sprintf(buf, "Bamfin: %s %s.\n\r", ch->name, ch->pcdata->bamfin);
act_info.c:	sprintf(buf, "Bamfout: %s %s.\n\r", ch->name, ch->pcdata->bamfout);
act_info.c:	sprintf(buf, "Bamfusee: You %s.\n\r", ch->pcdata->bamfusee);
act_info.c:	sprintf(buf, "Transto: Victim %s.\n\r", ch->pcdata->transto);
act_info.c:	sprintf(buf, "Transfrom: Victim %s.\n\r", ch->pcdata->transfrom);
act_info.c:	sprintf(buf, "Transvict: %s %s.\n\r", ch->name, ch->pcdata->transvict);
act_info.c:	sprintf(buf, "Slayusee: You %s.\n\r", ch->pcdata->slayusee);
act_info.c:	sprintf(buf, "Slayroom: %s %s.\n\r", ch->name, ch->pcdata->slayroom);
act_info.c:	sprintf(buf, "Slayvict: %s %s.\n\r", ch->name, ch->pcdata->slayvict);
act_info.c:	    ch->name,
act_info.c:	    IS_NPC(ch) ? "" : ch->pcdata->title);
act_info.c:	if (ch->pcdata->empowerments && *ch->pcdata->empowerments)
act_info.c:		    ch->pcdata->empowerments);
act_info.c:	if (ch->pcdata->detractments && *ch->pcdata->detractments)
act_info.c:		    ch->pcdata->detractments);
act_info.c:	    ch->level,
act_info.c:	    (get_race_data(ch->race))->race_full, class_long(ch));
act_info.c:    if (ch->clan) {
act_info.c:	clan = get_clan_index(ch->clan);
act_info.c:	if (ch->ctimer)
act_info.c:	    sprintf(buf + strlen(buf), "Clan skill timer: %d.\n\r", ch->ctimer);
act_info.c:	if (ch->cquestpnts > 0) {
act_info.c:	    sprintf(buf, "You currently have %d Clan Quest Points.\n\r", ch->cquestpnts);
act_info.c:    if (get_trust(ch) != ch->level) {
act_info.c:	sprintf(buf, "Afk Message: %s %s.\n\r", ch->name, ch->pcdata->afkchar);
act_info.c:    sprintf(buf, " %d/%d", ch->hit, MAX_HIT(ch));
act_info.c:	sprintf(buf, "%d/%d", ch->mana, MAX_MANA(ch));
act_info.c:	sprintf(buf, "%d/%d", ch->bp, MAX_BP(ch));
act_info.c:    sprintf(buf, "%d/%d", ch->move, MAX_MOVE(ch));
act_info.c:    sprintf(buf, "%d", ch->practice);
act_info.c:	    ch->carry_number, can_carry_n(ch),
act_info.c:	    ch->carry_weight, can_carry_w(ch));
act_info.c:	    IS_NPC(ch) ? 13 : ch->pcdata->perm_str, IS_NPC(ch) ? 13 : get_curr_str(ch),
act_info.c:	    IS_NPC(ch) ? 13 : ch->pcdata->perm_int, IS_NPC(ch) ? 13 : get_curr_int(ch),
act_info.c:	    IS_NPC(ch) ? 13 : ch->pcdata->perm_wis, IS_NPC(ch) ? 13 : get_curr_wis(ch),
act_info.c:	    IS_NPC(ch) ? 13 : ch->pcdata->perm_dex, IS_NPC(ch) ? 13 : get_curr_dex(ch),
act_info.c:	    IS_NPC(ch) ? 13 : ch->pcdata->perm_con, IS_NPC(ch) ? 13 : get_curr_con(ch),
act_info.c:	    IS_NPC(ch) ? 20 : ch->charisma);
act_info.c:    sprintf(buf, "%d experience points.\n\r", ch->exp);
act_info.c:	    ch->money.gold, ch->money.silver, ch->money.copper);
act_info.c:    sprintf(buf, "%d ", ch->exp);
act_info.c:    sprintf(buf, "%d ", ch->gold);
act_info.c:	    (!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOEXIT)) ? "yes"
act_info.c:	    (!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOLOOT)) ? "yes"
act_info.c:	    (!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOSAC)) ? "yes"
act_info.c:	    (!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOCOINS)) ? "yes"
act_info.c:	    (!IS_NPC(ch) && IS_SET(ch->act, PLR_AUTOSPLIT)) ? "yes"
act_info.c:    sprintf(buf, "Wimpy set to %d hit points.\n\r", ch->wimpy);
act_info.c:		ch->pcdata->pagelen);
act_info.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
act_info.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] == 0
act_info.c:	&& ch->level >= LEVEL_IMMORTAL)
act_info.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_FULL] == 0
act_info.c:	&& ch->level >= LEVEL_IMMORTAL)
act_info.c:    switch (ch->position) {
act_info.c:    if (ch->level >= 20) {
act_info.c:    if (ch->level >= 12) {
act_info.c:    if (ch->level >= 50) {
act_info.c:		(ch->race != RACE_DWARF) ? ch->saving_throw
act_info.c:		: ch->saving_throw + ch->saving_throw * 25 / 100);
act_info.c:    if (ch->level >= 8) {
act_info.c:	sprintf(buf, "Alignment: %d.  ", ch->alignment);
act_info.c:    if (ch->alignment > 900)
act_info.c:    else if (ch->alignment > 700)
act_info.c:    else if (ch->alignment > 350)
act_info.c:    else if (ch->alignment > 100)
act_info.c:    else if (ch->alignment > -100)
act_info.c:    else if (ch->alignment > -350)
act_info.c:    else if (ch->alignment > -700)
act_info.c:    else if (ch->alignment > -900)
act_info.c:		ch->wizinvis,
act_info.c:		IS_SET(ch->act, PLR_WIZINVIS) ? "ON" : "OFF");
act_info.c:		ch->cloaked,
act_info.c:		IS_SET(ch->act, PLR_CLOAKED) ? "ON" : "OFF");
act_info.c:/*    if ( ch->affected )
act_info.c:   for ( paf = ch->affected; paf; paf = paf->next )
act_info.c:   if ( ch->level >= 20 )
act_info.c:   if ( ch->affected2 )
act_info.c:   for ( paf = ch->affected2; paf; paf = paf->next )
act_info.c:   if ( ch->level >= 20 )
act_move.c:    in_room = ch->in_room;
act_move.c:      drunk = ch->pcdata->condition[COND_DRUNK];
act_move.c:        if ( !IS_AFFECTED( ch, AFF_PASS_DOOR ) && ch->race != RACE_SHADOW )
act_move.c:	&& ch->master
act_move.c:	&& in_room == ch->master->in_room && ( !Fall ) )
act_move.c:    if ( to_room->vnum == ROOM_VNUM_SMITHY && ch->race != RACE_DWARF && ( !Fall ) )
act_move.c:	       && ( ch->race != RACE_PIXIE )
act_move.c:	       && ( ch->race != RACE_ELDER ) ) 
act_move.c:	        || ( ch->race == RACE_PIXIE )
act_move.c:	        || ( ch->race == RACE_ELDER ) )
act_move.c:	    for ( obj = ch->carrying; obj; obj = obj->next_content )
act_move.c:	if ( ( ch->move < move ) && ( !Fall ) )
act_move.c:	   && ( ch->race != RACE_PIXIE     )
act_move.c:	   && ( ch->race != RACE_LIZARDMAN ) 
act_move.c:           && ( ch->race != RACE_ELDER     ) )
act_move.c:	   ch->move -= move;
act_move.c:	&& ( IS_NPC( ch ) || !IS_SET( ch->act, PLR_WIZINVIS ) ) 
act_move.c:	&& ( ch->race != RACE_HALFLING ) )
act_move.c:	   if ( ch->hit < MAX_HIT(ch) /2 )
act_move.c:	       obj_to_room( obj, ch->in_room );
act_move.c:	       && ( ch->race != RACE_PIXIE )
act_move.c:	       && ( ch->race != RACE_ELDER ) )
act_move.c:    eprog_enter_trigger( pexit, ch->in_room, ch );
act_move.c:    if ( ch->in_room != to_room )
act_move.c:	&& ( IS_NPC( ch ) || !IS_SET( ch->act, PLR_WIZINVIS ) )
act_move.c:	&& ( ch->race != RACE_HALFLING ) && ( !Fall ) )
act_move.c:      eprog_exit_trigger( to_room->exit[rev_dir[door]], ch->in_room, ch );
act_move.c:      rprog_enter_trigger( ch->in_room, ch );
act_move.c:        fch_next = fch->next_in_room;
act_move.c:        if ( fch->deleted )
act_move.c:	if ( fch->master == ch && fch->position == POS_STANDING )
act_move.c:       && ( ch->race != RACE_PIXIE ) && ( ch->race != RACE_ELDER ) ) 
act_move.c:      if ( !IS_SET( ch->act, PLR_WIZINVIS ) )
act_move.c:	    if ( ( pexit = ch->in_room->exit[door] )
act_move.c:    if ( !( pexit = ch->in_room->exit[door] ) )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	eprog_open_trigger( pexit, ch->in_room, ch );
act_move.c:	    && pexit_rev->to_room == ch->in_room )
act_move.c:	    for ( rch = to_room->people; rch; rch = rch->next_in_room )
act_move.c:		if ( rch->deleted )
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	eprog_close_trigger( pexit, ch->in_room, ch );
act_move.c:	    && pexit_rev->to_room == ch->in_room )
act_move.c:	    for ( rch = to_room->people; rch; rch = rch->next_in_room )
act_move.c:		if ( rch->deleted )
act_move.c:    for ( obj = ch->carrying; obj; obj = obj->next_content )
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	eprog_lock_trigger( pexit, ch->in_room, ch, key );
act_move.c:	    && pexit_rev->to_room == ch->in_room )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	eprog_unlock_trigger( pexit, ch->in_room, ch, key );
act_move.c:	    && pexit_rev->to_room == ch->in_room )
act_move.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
act_move.c:        if ( gch->deleted )
act_move.c:	if ( IS_NPC( gch ) && IS_AWAKE( gch ) && ch->level + 5 < gch->level )
act_move.c:    if ( !IS_NPC( ch ) && number_percent( ) > ch->pcdata->learned[gsn_pick_lock] )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	eprog_pick_trigger( pexit, ch->in_room, ch );
act_move.c:	    && pexit_rev->to_room == ch->in_room )
act_move.c:    switch ( ch->position )
act_move.c:	ch->position = POS_STANDING;
act_move.c:	rprog_wake_trigger( ch->in_room, ch );
act_move.c:	ch->position = POS_STANDING;
act_move.c:	rprog_wake_trigger( ch->in_room, ch );
act_move.c:    switch ( ch->position )
act_move.c:	ch->position = POS_RESTING;
act_move.c:	rprog_rest_trigger( ch->in_room, ch );
act_move.c:	rprog_rest_trigger( ch->in_room, ch );
act_move.c:	ch->position = POS_RESTING;
act_move.c:    switch ( ch->position )
act_move.c:	rprog_sleep_trigger( ch->in_room, ch );
act_move.c:	ch->position = POS_SLEEPING;
act_move.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_sneak] )
act_move.c:        af.level     = ch->level;
act_move.c:	af.duration  = ch->level;
act_move.c:       obj_to_room(obj,ch->in_room);
act_move.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_hide] )
act_move.c:        af.level     = ch->level;
act_move.c:	af.duration  = ch->level;
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_HIDE            );
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_PHASED          );
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_INVISIBLE	);
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_SNEAK		);
act_move.c:    if ( ch->level < 11 )
act_move.c:    if ( !strcmp( ch->name, "Jekka" ) )
act_move.c:    if (!(pClan=get_clan_index(ch->clan)))
act_move.c:       ch->clan = 0;
act_move.c:       pClan=get_clan_index(ch->clan);
act_move.c:    if ( ( ch->clan != 0 ) && ( ch->combat_timer < 1 ) && !IS_ARENA(ch) )
act_move.c:       place = ch->in_room->area->recall;
act_move.c:    if ( place == ROOM_VNUM_JEZ && ch->alignment < -350 )
act_move.c:    if ( ch->in_room == location )
act_move.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL )
act_move.c:    if ( ( victim = ch->fighting ) )
act_move.c:	      lose = ( ch->desc ) ? 50 : 100;
act_move.c:	  lose = ( ch->desc ) ? 100 : 200;
act_move.c:    for ( pet = ch->in_room->people; pet; pet = pet->next_in_room )
act_move.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
act_move.c:	sprintf( buf, "You have %d practice sessions.\n\r", ch->practice );
act_move.c:	pAbility    = &ch->pcdata->perm_str;
act_move.c:	pAbility    = &ch->pcdata->perm_int;
act_move.c:	pAbility    = &ch->pcdata->perm_wis;
act_move.c:	pAbility    = &ch->pcdata->perm_dex;
act_move.c:	pAbility    = &ch->pcdata->perm_con;
act_move.c:        pAbility    = &ch->perm_hit;
act_move.c:        pAbility    = &ch->perm_mana;
act_move.c:	pAbility    = &ch->perm_bp;
act_move.c:        pAbility    = &ch->perm_move;
act_move.c:	if ( ch->pcdata->perm_str < 18 ) strcat( buf, " str" );
act_move.c:	if ( ch->pcdata->perm_int < 18 ) strcat( buf, " int" );
act_move.c:	if ( ch->pcdata->perm_wis < 18 ) strcat( buf, " wis" );
act_move.c:	if ( ch->pcdata->perm_dex < 18 ) strcat( buf, " dex" );
act_move.c:	if ( ch->pcdata->perm_con < 18 ) strcat( buf, " con" );
act_move.c:    if ( ( cost*amt ) > ch->practice )
act_move.c:    ch->practice        	-= cost*amt;
act_move.c:        REMOVE_BIT( ch->affected_by, AFF_HIDE );
act_move.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_chameleon] )
act_move.c:	af.level     = ch->level;
act_move.c:	af.duration  = ch->level;
act_move.c:     /*   SET_BIT( ch->affected_by, AFF_HIDE );*/
act_move.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_heighten] )
act_move.c:        af.level     = ch->level;
act_move.c:	af.duration  = ch->level;
act_move.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_shadow] )
act_move.c:        af.level     = ch->level;
act_move.c:	af.duration  = ch->level;
act_move.c:    if ( !( obj = get_obj_list( ch, arg1, ch->in_room->contents ) ) )
act_move.c:    in_room = ch->in_room;
act_move.c:    rprog_exit_trigger( ch->in_room, ch );
act_move.c:        fch_next = fch->next_in_room;
act_move.c:        if ( fch->deleted )
act_move.c:	if ( fch->master == ch && fch->position == POS_STANDING )
act_move.c:    rprog_enter_trigger( ch->in_room, ch );
act_move.c:    if ( ch->fighting )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	chance = ch->pcdata->learned[gsn_bash_door]/2;
act_move.c:		&& pexit_rev->to_room == ch->in_room        )
act_move.c:		for ( rch = to_room->people; rch; rch = rch->next_in_room )
act_move.c:		    if ( rch->deleted )
act_move.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
act_move.c:        if ( gch->deleted )
act_move.c:	    && !gch->fighting
act_move.c:	    && ( ch->level - gch->level <= 4 )
act_move.c:                 || IS_SET( ch->in_room->room_flags, ROOM_SMITHY )
act_move.c:                 || IS_SET( ch->in_room->room_flags, ROOM_BANK )   
act_move.c:/*  if(abs(ch->level - victim->level) > 5 && !IS_IMMORTAL(ch))
act_move.c:    && ch->clan == 0)
act_move.c:  pexit = ch->in_room->exit[door];
act_move.c:                 || IS_SET( ch->in_room->room_flags, ROOM_SMITHY )
act_move.c:                 || IS_SET( ch->in_room->room_flags, ROOM_BANK )
act_move.c:/*  if(abs(ch->level - victim->level) > 5 && !IS_IMMORTAL(ch))
act_move.c:    && ch->clan == 0)
act_move.c:  pexit = ch->in_room->exit[door];
act_move.c:  from_room = ch->in_room;
act_move.c:  eprog_enter_trigger( pexit, ch->in_room, ch );
act_move.c:    eprog_exit_trigger( pexit, ch->in_room, ch );
act_move.c:    rprog_enter_trigger( ch->in_room, ch );
act_move.c:  if ( IS_SET( ch->in_room->room_flags, ROOM_NOFLOOR ) 
act_move.c:      && ( ( pexit = ch->in_room->exit[5] ) != NULL )
act_move.c:      && ( ch->race != RACE_PIXIE ) && ( ch->race != RACE_ELDER ) )
act_move.c:    if ( ch->fighting )
act_move.c:	|| victim->in_room->area != ch->in_room->area
act_move.c:	|| IS_SET( ch->in_room->room_flags, ROOM_NO_SHADOW )
act_move.c:	||   victim->in_room->area != ch->in_room->area
act_move.c:	||   IS_SET( ch->in_room->room_flags, ROOM_NO_SHADOW )
act_move.c:  if ( ch->pcdata->learned[gsn_scent] < number_percent( ) )
act_move.c:  in_room = ch->in_room;
act_move.c:	for ( sch = next_room->people; sch; sch = sch->next_in_room )
act_move.c:	    if ( sch->deleted )
act_move.c:	    if ( !(sch->desc)
act_move.c:  if ( !ch->fighting )
act_move.c:  for ( smokebomb = ch->carrying; smokebomb; smokebomb = smokebomb->next )
act_move.c:  if ( number_percent( ) < ch->pcdata->learned[gsn_retreat] )
act_move.c:   in_room = ch->in_room;
act_move.c:    ch->position = POS_STUNNED;
act_move.c:      ch->position = POS_STUNNED;
act_move.c:   obj_to_room( smokebomb, ch->in_room );
act_obj.c:    if (ch->carry_number + get_obj_number(obj) > can_carry_n(ch)) {
act_obj.c:    if (ch->carry_weight + get_obj_weight(obj) > can_carry_w(ch)) {
act_obj.c:	if (ch->in_room->vnum == ROOM_VNUM_DON_1
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_2
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_3
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_4
act_obj.c:	if (ch->in_room->vnum == ROOM_VNUM_DON_1
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_2
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_3
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_4
act_obj.c:   if ( ( ch->carry_weight + tot_coins/100 ) > can_carry_w( ch ) )
act_obj.c:   ch->carry_weight += tot_coins/100; 
act_obj.c:	add_money(&ch->money, &amount);
act_obj.c:	if (IS_SET(ch->act, PLR_AUTOSPLIT) && (amount.gold +
act_obj.c:	ch->gold += amount;
act_obj.c:	if (IS_SET(ch->act, PLR_AUTOSPLIT) && amount > 1) {
act_obj.c:	if (ch->in_room->vnum == ROOM_VNUM_DON_1
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_2
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_3
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_4
act_obj.c:    if (number_percent() > ch->pcdata->learned[gsn_palm])
act_obj.c:	    obj = get_obj_list(ch, arg1, ch->in_room->contents);
act_obj.c:	    for (obj = ch->in_room->contents; obj; obj = obj_next) {
act_obj.c:		if (str_cmp(name, ch->name) && !IS_IMMORTAL(ch)) {
act_obj.c:		    for (gch = char_list; gch; gch = gch->next) {
act_obj.c:			    && !str_cmp(name, gch->name)) {
act_obj.c:		    if (ch->clan != 0)
act_obj.c:	for (obj = ch->carrying; obj; obj = obj_next) {
act_obj.c:	for (obj = ch->in_room->contents; obj; obj = obj_next) {
act_obj.c:		    howmuch->gold += 1;
act_obj.c:		    howmuch->silver += 1;
act_obj.c:		    howmuch->copper += 1;
act_obj.c:		howmuch->gold += obj->value[0];
act_obj.c:		howmuch->silver += obj->value[1];
act_obj.c:		howmuch->copper += obj->value[2];
act_obj.c:	obj_to_room(create_money(howmuch), ch->in_room);
act_obj.c:	if (ch->gold < amount) {
act_obj.c:	ch->gold -= amount;
act_obj.c:	for (obj = ch->in_room->contents; obj; obj = obj_next) {
act_obj.c:	obj_to_room(create_money(amount), ch->in_room);
act_obj.c:	if (ch->in_room->vnum == ROOM_VNUM_DON_1
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_2
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_3
act_obj.c:	    || ch->in_room->vnum == ROOM_VNUM_DON_4
act_obj.c:	obj_to_room(obj, ch->in_room);
act_obj.c:	for (obj = ch->carrying; obj; obj = obj_next) {
act_obj.c:		if (ch->in_room->vnum == ROOM_VNUM_DON_1
act_obj.c:		    || ch->in_room->vnum == ROOM_VNUM_DON_2
act_obj.c:		    || ch->in_room->vnum == ROOM_VNUM_DON_3
act_obj.c:		    || ch->in_room->vnum == ROOM_VNUM_DON_4
act_obj.c:		obj_to_room(obj, ch->in_room);
act_obj.c:		can_see(victim, ch) ? ch->name : "someone", money_string(howmuch));
act_obj.c:	if (ch->gold < amount) {
act_obj.c:	ch->gold -= amount;
act_obj.c:		can_see(victim, ch) ? ch->name : "someone", amount);
act_obj.c:    for (fountain = ch->in_room->contents; fountain;
act_obj.c:	for (obj = ch->in_room->contents; obj; obj = obj->next_content) {
act_obj.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] >= 90) {
act_obj.c:	if ((ch->bp + 1) > MAX_BP(ch)) {
act_obj.c:	    ch->bp = MAX_BP(ch);
act_obj.c:	if ((ch->bp + obj->value[1]) > MAX_BP(ch)) {
act_obj.c:	    obj->value[1] = (obj->value[1] - (MAX_BP(ch) - ch->bp));
act_obj.c:	    ch->bp = MAX_BP(ch);
act_obj.c:	    ch->bp += obj->value[1];
act_obj.c:	for (obj = ch->in_room->contents; obj; obj = obj->next_content) {
act_obj.c:    if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] >= 90) {
act_obj.c:	if ((ch->bp + 1) > MAX_BP(ch)) {
act_obj.c:	ch->bp += 1;
act_obj.c:	    ch->pcdata->condition[COND_THIRST] = 58;	/*  48  */
act_obj.c:	if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 100)
act_obj.c:	    ch->pcdata->condition[COND_DRUNK] = 100;
act_obj.c:	if (!IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10)
act_obj.c:	if (!IS_NPC(ch) && ch->pcdata->condition[COND_FULL] > MAX_FULL)
act_obj.c:	if (!IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] > MAX_THIRST)
act_obj.c:	if ((obj->item_type == ITEM_CORPSE_NPC && ch->race != RACE_GHOUL)
act_obj.c:	    || (obj->item_type == ITEM_FOOD && ch->race == RACE_GHOUL)) {
act_obj.c:	if (!IS_NPC(ch) && ch->pcdata->condition[COND_FULL] > MAX_FULL) {
act_obj.c:	    condition = ch->pcdata->condition[COND_FULL];
act_obj.c:	    if (ch->pcdata->condition[COND_FULL] > MAX_FULL)
act_obj.c:	    else if (condition == 0 && ch->pcdata->condition[COND_FULL] > 0)
act_obj.c:	ch->hit = UMIN(ch->hit + amnt, MAX_HIT(ch));
act_obj.c:	if (ch->level >= obj->level) {
act_obj.c:	if (!IS_NPC(ch) && ch->race == RACE_GHOUL) {
act_obj.c:	    if (ch->pcdata->condition[COND_FULL] > MAX_FULL)
act_obj.c:	    else if (condition == 0 && ch->pcdata->condition[COND_FULL] > 0)
act_obj.c:    if (ch->level < obj->level) {
act_obj.c:    if (ch->level < obj->level) {
act_obj.c:    if (ch->pcdata->learned[gsn_dual] == 0) {
act_obj.c:	for (obj = ch->carrying; obj; obj = obj_next) {
act_obj.c:	for (obj = ch->carrying; obj != NULL; obj = obj_next) {
act_obj.c:    if (arg[0] == '\0' || !str_cmp(arg, ch->name)) {
act_obj.c:	for (obj = ch->in_room->contents; obj; obj = obj_next) {
act_obj.c:    obj = get_obj_list(ch, arg, ch->in_room->contents);
act_obj.c:	ch->money.copper += award;
act_obj.c:	ch->gold += award;
act_obj.c:	if (ch->hit >= MAX_HIT(ch))
act_obj.c:	ch->hit += award;
act_obj.c:	    if (ch->mana >= MAX_MANA(ch))
act_obj.c:	    ch->mana += award;
act_obj.c:	    if (ch->bp >= MAX_BP(ch))
act_obj.c:	    ch->bp += award;
act_obj.c:	if (ch->move >= MAX_MOVE(ch))
act_obj.c:	ch->move += award;
act_obj.c:	ch->money.silver += 3;
act_obj.c:	ch->gold += 6;
act_obj.c:    if (obj->level > ch->level)
act_obj.c:	&& !(number_percent() < ch->pcdata->learned[gsn_scrolls])) {
act_obj.c:    if (scroll->level > ch->level)
act_obj.c:	    && !(number_percent() < ch->pcdata->learned[gsn_staves])) {
act_obj.c:	for (vch = ch->in_room->people; vch; vch = vch_next) {
act_obj.c:	    vch_next = vch->next_in_room;
act_obj.c:	    if (vch->deleted)
act_obj.c:    if (arg[0] == '\0' && !ch->fighting) {
act_obj.c:	if (ch->fighting) {
act_obj.c:	    victim = ch->fighting;
act_obj.c:    if (arg[0] == '\0' && !ch->fighting) {
act_obj.c:	if (ch->fighting) {
act_obj.c:	    victim = ch->fighting;
act_obj.c:	    && !(number_percent() < ch->pcdata->learned[gsn_wands])) {
act_obj.c:    if (abs(ch->level - victim->level) > 5 && (!IS_NPC(victim))) {
act_obj.c:    if (ch->level + 5 < victim->level
act_obj.c:	|| (!IS_NPC(ch) && percent > ch->pcdata->learned[gsn_steal])) {
act_obj.c:	if (ch->guild && !strcmp(ch->guild->name, "MERCENARY")) {
act_obj.c:	    ch->guild = NULL;
act_obj.c:	    ch->guild_rank = 0;
act_obj.c:	sprintf(buf, "%s is a bloody thief!", ch->name);
act_obj.c:		if (!IS_SET(ch->act, PLR_THIEF)) {
act_obj.c:		    SET_BIT(ch->act, PLR_THIEF);
act_obj.c:	add_money(&ch->money, &amount);
act_obj.c:	ch->gold += amount;
act_obj.c:	|| obj->level > ch->level) {
act_obj.c:    if (ch->carry_number + get_obj_number(obj) > can_carry_n(ch)) {
act_obj.c:    if (ch->carry_weight + get_obj_weight(obj) > can_carry_w(ch)) {
act_obj.c:    for (keeper = ch->in_room->people; keeper; keeper = keeper->next_in_room) {
act_obj.c:    if (!IS_NPC(ch) && IS_SET(ch->act, PLR_KILLER)) {
act_obj.c:	sprintf(buf, "%s the KILLER is over here!\n\r", ch->name);
act_obj.c:    if (!IS_NPC(ch) && IS_SET(ch->act, PLR_THIEF)) {
act_obj.c:	sprintf(buf, "%s the THIEF is over here!\n\r", ch->name);
act_obj.c:    if (IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP)) {
act_obj.c:	pRoomIndexNext = get_room_index(ch->in_room->vnum + 1);
act_obj.c:	    bug("Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum);
act_obj.c:	in_room = ch->in_room;
act_obj.c:	ch->in_room = pRoomIndexNext;
act_obj.c:	ch->in_room = in_room;
act_obj.c:	if (IS_SET(ch->act, PLR_BOUGHT_PET)) {
act_obj.c:	if ((ch->money.gold * C_PER_G + ch->money.silver * S_PER_G +
act_obj.c:	     ch->money.copper) < (pet_cost.gold * 100)) {
act_obj.c:	if (ch->level < pet->level) {
act_obj.c:	spend_money(&ch->money, &pet_cost);
act_obj.c:	if (ch->gold < 10 * pet->level * pet->level) {
act_obj.c:	if (ch->level < pet->level) {
act_obj.c:	ch->gold -= 10 * pet->level * pet->level;
act_obj.c:	if (ch->level < LEVEL_HERO)
act_obj.c:	    SET_BIT(ch->act, PLR_BOUGHT_PET);
act_obj.c:		pet->description, ch->name);
act_obj.c:	char_to_room(pet, ch->in_room);
act_obj.c:	    ch->reply = keeper;
act_obj.c:	    && ch->pcdata->learned[gsn_haggle] > 0
act_obj.c:	if (ch->charisma > 24) {
act_obj.c:	} else if (ch->charisma > 19 && ch->charisma < 25) {
act_obj.c:	} else if (ch->charisma < 15) {
act_obj.c:	} else if (ch->charisma < 20) {
act_obj.c:	if ((ch->money.gold * C_PER_G + ch->money.silver * S_PER_G +
act_obj.c:	     ch->money.copper) < (cost->gold * C_PER_G + cost->silver * S_PER_G +
act_obj.c:	    ch->reply = keeper;
act_obj.c:	if (obj->level > ch->level) {
act_obj.c:	    ch->reply = keeper;
act_obj.c:	if (ch->carry_number + (get_obj_number(obj) * noi) > can_carry_n(ch)) {
act_obj.c:	if (ch->carry_weight + (get_obj_weight(obj) * noi) > can_carry_w(ch)) {
act_obj.c:	spend_money(&ch->money, cost);
act_obj.c:	    ch->reply = keeper;
act_obj.c:	    && ch->pcdata->learned[gsn_haggle] > 0
act_obj.c:	if (ch->gold < cost) {
act_obj.c:	    ch->reply = keeper;
act_obj.c:	if (obj->level > ch->level) {
act_obj.c:	    ch->reply = keeper;
act_obj.c:	if (ch->carry_number + (get_obj_number(obj) * noi) > can_carry_n(ch)) {
act_obj.c:	if (ch->carry_weight + (get_obj_weight(obj) * noi) > can_carry_w(ch)) {
act_obj.c:	ch->gold -= cost;
act_obj.c:    if (ch->in_room->vnum == ROOM_VNUM_ARTIFACTOR) {
act_obj.c:    } else if (IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP)) {
act_obj.c:	pRoomIndexNext = get_room_index(ch->in_room->vnum + 1);
act_obj.c:	    bug("Do_list: bad pet shop at vnum %d.", ch->in_room->vnum);
act_obj.c:	ch->reply = keeper;
act_obj.c:	ch->reply = keeper;
act_obj.c:	ch->reply = keeper;
act_obj.c:	&& ch->pcdata->learned[gsn_haggle] > 0) {
act_obj.c:    if (ch->charisma > 24) {
act_obj.c:    if (ch->charisma > 19 && ch->charisma < 24) {
act_obj.c:    if (ch->charisma < 15) {
act_obj.c:    if (ch->charisma < 20) {
act_obj.c:    add_money(&ch->money, cost);
act_obj.c:	ch->reply = keeper;
act_obj.c:	&& ch->pcdata->learned[gsn_haggle] > 0)
act_obj.c:    ch->gold += cost;
act_obj.c:	ch->reply = keeper;
act_obj.c:	ch->reply = keeper;
act_obj.c:	ch->reply = keeper;
act_obj.c:    ch->reply = keeper;
act_obj.c:    if (ch->fighting) {
act_obj.c:	    || ch->pcdata->condition[COND_DRUNK] > 0)) {
act_obj.c:	&& number_percent() > ch->pcdata->learned[gsn_poison_weapon]) {
act_obj.c:	damage(ch, ch, ch->level, gsn_poison_weapon);
act_obj.c:    obj->cost.gold *= ch->level;
act_obj.c:    obj->cost.silver *= ch->level;
act_obj.c:    obj->cost.copper *= ch->level;
act_obj.c:    obj->cost *= ch->level;
act_obj.c:	obj_to_room(nObj, ch->in_room);
act_obj.c:	obj_to_room(nObj, ch->in_room);
act_obj.c:    char_to_room(victim, ch->in_room);
act_obj.c:    if (ch->in_room->vnum == 8) {
act_obj.c:    if (ch->fighting) {
act_obj.c:    if (ch->level < obj->level) {
act_obj.c:	obj_to_room(obj, ch->in_room);
act_obj.c:    if (ch->clan != 5) {
act_obj.c:    if (saves_spell(ch->level, victim)) {
act_obj.c:    if (!IS_SET(ch->in_room->room_flags, ROOM_BANK)) {
act_obj.c:    pClan = get_clan_index(ch->clan);
act_obj.c:    if ((amount.gold > ch->money.gold) ||
act_obj.c:	(amount.silver > ch->money.silver) ||
act_obj.c:	(amount.copper > ch->money.copper)) {
act_obj.c:	    amount.gold = ch->money.gold;
act_obj.c:	    amount.silver = ch->money.silver;
act_obj.c:	    amount.copper = ch->money.copper;
act_obj.c:	    if ((IS_SET(ch->in_room->area->area_flags, AREA_CLAN_HQ)) &&
act_obj.c:	    add_money(&ch->pcdata->bankaccount, &amount);
act_obj.c:	sub_money(&ch->money, &amount);
act_obj.c:		    money_string(&ch->pcdata->bankaccount));
act_obj.c:    if ((!is_number(arg) && (str_cmp(arg, "all"))) || (money > ch->gold)
act_obj.c:	    money = ch->gold;
act_obj.c:	ch->pcdata->bankaccount += money;
act_obj.c:	ch->gold -= money;
act_obj.c:		money, money > 1 ? "s" : "", ch->pcdata->bankaccount);
act_obj.c:    if (!IS_SET(ch->in_room->room_flags, ROOM_BANK)) {
act_obj.c:    pClan = get_clan_index(ch->clan);
act_obj.c:	if ((IS_SET(ch->in_room->area->area_flags, AREA_CLAN_HQ)) &&
act_obj.c:	if ((amount.gold > ch->pcdata->bankaccount.gold) ||
act_obj.c:	    (amount.silver > ch->pcdata->bankaccount.silver) ||
act_obj.c:	    (amount.copper > ch->pcdata->bankaccount.copper)) {
act_obj.c:	    amount.gold = ch->pcdata->bankaccount.gold;
act_obj.c:	    amount.silver = ch->pcdata->bankaccount.silver;
act_obj.c:	    amount.copper = ch->pcdata->bankaccount.copper;
act_obj.c:	add_money(&ch->money, &amount);
act_obj.c:	    sub_money(&ch->pcdata->bankaccount, &amount);
act_obj.c:		    money_string(&ch->pcdata->bankaccount));
act_obj.c:	|| money > ch->pcdata->bankaccount
act_obj.c:	    money = ch->pcdata->bankaccount;
act_obj.c:	ch->pcdata->bankaccount -= money;
act_obj.c:	ch->gold += money;
act_obj.c:		money, money > 1 ? "s" : "", ch->pcdata->bankaccount);
act_obj.c:    if (!IS_SET(ch->in_room->room_flags, ROOM_SMITHY)) {
act_obj.c:	for (pObj = ch->carrying; pObj; pObj = pObj->next_content) {
act_obj.c:		((ch->money.gold * 100) + (ch->money.silver * 10) + (ch->money.copper))) {
act_obj.c:	    spend_money(&ch->money, &amount);
act_obj.c:    if (((ch->money.gold * 100) + (ch->money.silver * 10) + (ch->money.copper)) <
act_obj.c:	sub_money(&ch->money, &amount);
act_obj.c:	for (pObj = ch->carrying; pObj; pObj = pObj->next_content) {
act_obj.c:	    if (cost > ch->gold) {
act_obj.c:	    ch->gold -= cost;
act_obj.c:    if (ch->gold < cost) {
act_obj.c:	ch->gold -= cost;
act_obj.c:	if (!IS_SET(ch->in_room->room_flags, ROOM_BANK)) {
act_obj.c:	if ((ch->pcdata->bankaccount.gold + ch->pcdata->bankaccount.silver +
act_obj.c:	     ch->pcdata->bankaccount.copper) > 0) {
act_obj.c:	    sprintf(buf, "Your account holds %s\n\r", money_string(&ch->pcdata->bankaccount));
act_obj.c:	    len = strlen(ch->name);
act_obj.c:		    ch->name[len] == 's' ? "" : "s");
act_obj.c:    clanacct = get_clan_index(ch->clan);
act_obj.c:    if ((IS_SET(ch->in_room->area->area_flags, AREA_CLAN_HQ))
act_obj.c:	if (ch->pcdata->bankaccount > 0) {
act_obj.c:		    ch->pcdata->bankaccount,
act_obj.c:		    ch->pcdata->bankaccount > 1 ? "s" : "");
act_obj.c:	    len = strlen(ch->name);
act_obj.c:		    ch->name[len] == 's' ? "" : "s");
act_obj.c:    if (!IS_SET(ch->in_room->room_flags, ROOM_BANK)) {
act_obj.c:    if (IS_SET(ch->act, PLR_THIEF)) {
act_obj.c:	show_list_to_char(ch->pcdata->storage, ch, TRUE, TRUE);
act_obj.c:    if (ch->pcdata->storcount >= 9) {
act_obj.c:    if (((ch->pcdata->bankaccount.gold * 100) + (ch->pcdata->bankaccount.silver * 10) +
act_obj.c:	 (ch->pcdata->bankaccount.copper)) < storage * 100)
act_obj.c:    if (ch->pcdata->bankaccount < 1000)
act_obj.c:    spend_money(&ch->pcdata->bankaccount, &amt);
act_obj.c:    ch->pcdata->bankaccount -= 1000;
act_obj.c:    if (!IS_SET(ch->in_room->room_flags, ROOM_BANK)) {
act_obj.c:    if (IS_SET(ch->act, PLR_THIEF)) {
act_obj.c:    if (ch->pcdata->learned[gsn_patch] <= 0) {
act_obj.c:	for (obj = ch->carrying; obj; obj = obj->next_content) {
act_obj.c:	    ammount = ch->pcdata->learned[gsn_patch] / 2;
act_obj.c:    ammount = ch->pcdata->learned[gsn_patch] / 2;
act_obj.c:    if (ch->fighting) {
act_obj.c:    for (pobj = ch->carrying; pobj; pobj = pobj->next_content) {
act_obj.c:    for (cobj = ch->carrying; cobj; cobj = cobj->next_content) {
act_obj.c:    for (fobj = ch->carrying; fobj; fobj = fobj->next_content) {
act_obj.c:    if (ch->mana < mana) {
act_obj.c:    ch->mana -= mana;
act_obj.c:    dam = ch->level * (skill_table[sn].skill_level[prime_class(ch)] / 9);
act_obj.c:    chance = ch->pcdata->learned[gsn_alchemy]
act_obj.c:    pobj->value[0] = ch->level / 2 - 1;
act_obj.c:    pobj->level = ch->level / 2 - 1;
act_obj.c:    pobj->cost.gold = ch->level * skill_table[sn].skill_level[prime_class(ch)];
act_obj.c:    pobj->cost = ch->level * skill_table[sn].skill_level[prime_class(ch)];
act_obj.c:    if (ch->fighting) {
act_obj.c:    for (pobj = ch->carrying; pobj; pobj = pobj->next_content) {
act_obj.c:    for (cobj = ch->carrying; cobj; cobj = cobj->next_content) {
act_obj.c:    for (fobj = ch->carrying; fobj; fobj = fobj->next_content) {
act_obj.c:    if (ch->mana < mana) {
act_obj.c:    ch->mana -= mana;
act_obj.c:    dam = ch->level * (skill_table[sn].skill_level[prime_class(ch)] / 9);
act_obj.c:    chance = ch->pcdata->learned[gsn_scribe]
act_obj.c:    pobj->value[0] = ch->level / 2 - 1;
act_obj.c:    pobj->level = ch->level / 2 - 1;
act_obj.c:    pobj->cost.gold = ch->level * skill_table[sn].skill_level[prime_class(ch)];
act_obj.c:    pobj->cost = ch->level * skill_table[sn].skill_level[prime_class(ch)];
act_obj.c:    obj = get_obj_list(ch, arg, ch->in_room->contents);
act_obj.c:    if (ch->pcdata->learned[gsn_gravebind] < number_percent()) {
act_obj.c:    hp = UMAX(20, ch->level + ch->level / 2);
act_obj.c:    ch->hit += hp;
act_obj.c:    ch->hit = UMIN(MAX_HIT(ch), ch->hit);
act_obj.c:    if (ch->in_room->vnum != ROOM_VNUM_ARTIFACTOR) {
act_obj.c:    if (((ch->money.gold * C_PER_G) + (ch->money.silver * S_PER_G) +
act_obj.c:	 (ch->money.copper)) < amount.gold * C_PER_G) {
act_obj.c:    spend_money(&ch->money, &amount);
act_obj.c:    if (ch->gold < price) {
act_obj.c:    ch->gold -= price;
act_obj.c:    for (gch = ch->in_room->people; gch; gch = gch->next_in_room) {
act_obj.c:    if (ch->in_room->vnum != ROOM_VNUM_ARTIFACTOR) {
act_obj.c:    if ((ch->money.gold * C_PER_G + ch->money.silver * S_PER_G +
act_obj.c:	 ch->money.copper) < amount.gold * C_PER_G) {
act_obj.c:    spend_money(&ch->money, &amount);
act_obj.c:    if (ch->gold < 7000000) {
act_obj.c:    ch->gold -= 7000000;
act_obj.c:    if (ch->pcdata->learned[gsn_flamehand] < number_percent()) {
act_obj.c:    af.level = ch->level;
act_obj.c:    af.duration = 20 + (5 * (ch->level > 75)) + (10 * (ch->level > 95));
act_obj.c:    if (ch->pcdata->learned[gsn_frosthand] < number_percent()) {
act_obj.c:    af.level = ch->level;
act_obj.c:    af.duration = 25 + (5 * (ch->level > 85)) + (10 * (ch->level > 95));
act_obj.c:    if (ch->pcdata->learned[gsn_chaoshand] < number_percent()) {
act_obj.c:    af.level = ch->level;
act_obj.c:    af.duration = 20 + (5 * (ch->level > 90)) + (10 * (ch->level >= 100));
act_obj.c:    if (ch->pcdata->learned[gsn_ironfist] < number_percent()) {
act_obj.c:    af.level = ch->level;
act_obj.c:    af.duration = ch->level / 2;
act_obj.c:    af.modifier = ch->level / 2;
act_obj.c:    af.modifier = ch->level / 3;
act_obj.c:	|| ch->pcdata->learned[gsn_snatch] < number_percent()) {
act_obj.c:    ch->wait = 0;
act_obj.c:    for (flask = ch->carrying; flask; flask = flask->next_content) {
act_obj.c:    flask->value[0] = ch->level;
act_room.c: * Slap a rAffect on a room and update ch->powered.
act_room.c:    pd->next = ch->powered;
act_room.c:    if (ch->race == RACE_ELDER || ch->race == RACE_ELF)
act_room.c:    ch->powered = pd;
act_room.c: * Remove and delete a rAffect and update ch->powered.
act_room.c:    if (ch->in_room == room)
act_room.c:    for (pd = ch->powered; pd; ppd = pd, pd = pd->next) {
act_room.c:		ch->powered = pd->next;
act_room.c:    if (!ch->powered)
act_room.c:    for (pd = ch->powered; pd; pd = pd->next) {
act_room.c:    if (ch->level >= L_APP) {
act_room.c:	for (raf = ch->in_room->rAffect; raf; raf = raf->next) {
act_room.c:    for (pd = ch->powered; pd; pd = pd_next) {
act_room.c:	for (pd = ch->powered; pd; pd = pd->next) {
act_room.c:    if (!is_raffected(ch->in_room, gsn_raf)) {
act_room.c:    for (pd = ch->powered; pd; pd = pd->next) {
act_room.c:	    if (pd->room == ch->in_room) {
act_room.c:		raffect_remove(ch->in_room, ch, pd->raf);
act_room.c:    if (ch->pcdata->learned[type] < number_percent()) {
act_room.c:	&& IS_SET(ch->in_room->room_flags, ROOM_SAFE)) {
act_room.c:	&& is_raffected(ch->in_room, gsn_ward_heal)) {
act_room.c:    raf.room = ch->in_room;
act_room.c:    raffect_to_room(ch->in_room, ch, &raf);
act_wiz.c:    if (!is_name(NULL, "empower", ch->pcdata->empowerments)
act_wiz.c:	&& ch->level != L_IMP) {
act_wiz.c:    if (!is_name(NULL, "detract", ch->pcdata->empowerments)
act_wiz.c:	&& ch->level != L_IMP) {
act_wiz.c:	    sprintf(buf, "Slayusee: %s\n\r", ch->pcdata->slayusee);
act_wiz.c:	    ch->pcdata->slayusee = str_dup(argument);
act_wiz.c:	    sprintf(buf, "Slayroom: %s\n\r", ch->pcdata->slayroom);
act_wiz.c:	    ch->pcdata->slayroom = str_dup(argument);
act_wiz.c:	    sprintf(buf, "Slayvict: %s\n\r", ch->pcdata->slayvict);
act_wiz.c:	    ch->pcdata->slayvict = str_dup(argument);
act_wiz.c:	    sprintf(buf, "Transto: %s\n\r", ch->pcdata->transto);
act_wiz.c:	    free_string(ch->pcdata->transto);
act_wiz.c:	    ch->pcdata->transto = str_dup(argument);
act_wiz.c:	    sprintf(buf, "Transfrom: %s\n\r", ch->pcdata->transfrom);
act_wiz.c:	    free_string(ch->pcdata->transfrom);
act_wiz.c:	    ch->pcdata->transfrom = str_dup(argument);
act_wiz.c:	    sprintf(buf, "Transvict:%s", ch->pcdata->transvict);
act_wiz.c:	    free_string(ch->pcdata->transvict);
act_wiz.c:	    ch->pcdata->transvict = str_dup(argument);
act_wiz.c:	    sprintf(buf, "Poofout: %s\n\r", ch->pcdata->bamfout);
act_wiz.c:	    free_string(ch->pcdata->bamfout);
act_wiz.c:	    ch->pcdata->bamfout = str_dup(argument);
act_wiz.c:	    sprintf(buf, "Poofin: %s\n\r", ch->pcdata->bamfin);
act_wiz.c:	    free_string(ch->pcdata->bamfin);
act_wiz.c:	    ch->pcdata->bamfin = str_dup(argument);
act_wiz.c:	    sprintf(buf, "Poofusee: %s\n\r", ch->pcdata->bamfusee);
act_wiz.c:	    free_string(ch->pcdata->bamfusee);
act_wiz.c:	    ch->pcdata->bamfusee = str_dup(argument);
act_wiz.c:    if (ch->level != L_IMP) {
act_wiz.c:	    && d->character->in_room == ch->in_room) {
act_wiz.c:	location = ch->in_room;
act_wiz.c:	    (ch->pcdata && ch->pcdata->transfrom[0] != '\0')
act_wiz.c:	    ? ch->pcdata->transfrom : "disappears in a mushroom cloud.");
act_wiz.c:	    (ch->pcdata && ch->pcdata->transto[0] != '\0')
act_wiz.c:	    ? ch->pcdata->transto : "arrives from a puff of smoke");
act_wiz.c:	sprintf(buf, "%s %s.", ch->name,
act_wiz.c:		(ch->pcdata && ch->pcdata->transvict[0] != '\0')
act_wiz.c:		? ch->pcdata->transvict : "has transferred you");
act_wiz.c:    original = ch->in_room;
act_wiz.c:    for (wch = char_list; wch; wch = wch->next) {
act_wiz.c:    for (pet = ch->in_room->people; pet; pet = pet->next_in_room) {
act_wiz.c:    if (ch->fighting)
act_wiz.c:	(ch->pcdata && ch->pcdata->bamfusee[0] != '\0')
act_wiz.c:	? ch->pcdata->bamfusee : "leave in a swirling mist", TO_CHAR);
act_wiz.c:    if (!IS_SET(ch->act, PLR_WIZINVIS)) {
act_wiz.c:	    (ch->pcdata && ch->pcdata->bamfout[0] != '\0')
act_wiz.c:	    ? ch->pcdata->bamfout : "leaves in a swirling mist", TO_ROOM);
act_wiz.c:	for (gch = ch->in_room->people; gch; gch = gch->next_in_room) {
act_wiz.c:		if (get_trust(gch) >= ch->wizinvis) {
act_wiz.c:		    sprintf(buf, "%s slightly phased %s.\n\r", ch->name,
act_wiz.c:			    (ch->pcdata && ch->pcdata->bamfout[0] != '\0')
act_wiz.c:		    ? ch->pcdata->bamfout : "leaves in a swirling mist");
act_wiz.c:    if (location == ch->in_room) {
act_wiz.c:    startlocation = ch->in_room;
act_wiz.c:    if (!IS_SET(ch->act, PLR_WIZINVIS)) {
act_wiz.c:	    (ch->pcdata && ch->pcdata->bamfin[0] != '\0')
act_wiz.c:	    ? ch->pcdata->bamfin : "appears in a swirling mist", TO_ROOM);
act_wiz.c:	for (gch = ch->in_room->people; gch; gch = gch->next_in_room) {
act_wiz.c:		if (get_trust(gch) >= ch->wizinvis) {
act_wiz.c:		    sprintf(buf, "%s slightly phased %s.\n\r", ch->name,
act_wiz.c:			    (ch->pcdata && ch->pcdata->bamfin[0] != '\0')
act_wiz.c:		    ? ch->pcdata->bamfin : "appears in a swirling mist");
act_wiz.c:    if (pet && !IS_SET(ch->act, PLR_WIZINVIS))
act_wiz.c:    else if (pet && IS_SET(ch->act, PLR_WIZINVIS)) {
act_wiz.c:	for (gch = ch->in_room->people; gch; gch = gch->next_in_room) {
act_wiz.c:	    if (get_trust(gch) >= ch->wizinvis) {
act_wiz.c:	gch_next = gch->next_in_room;
act_wiz.c:	if (gch->deleted)
act_wiz.c:	if (gch->master == ch) {
act_wiz.c:    location = (arg[0] == '\0') ? ch->in_room : find_location(ch, arg);
act_wiz.c:    if (ch->in_room != location && room_is_private(location) &&
act_wiz.c:    for (rch = location->people; rch; rch = rch->next_in_room) {
act_wiz.c:	one_argument(rch->name, buf + 1);
act_wiz.c:    pArea = ch->in_room->area;
act_wiz.c:	sprintf(buf, "Reboot by %s.", ch->name);
act_wiz.c:/*    if ( !str_cmp( ch->name, "Hannibal" ) )
act_wiz.c:   sprintf( buf, "Nuclear Meltdown by %s.", ch->name );
act_wiz.c:    sprintf(buf, "Shutdown by %s.", ch->name);
act_wiz.c:	    if (d->snoop_by == ch->desc)
act_wiz.c:    if (ch->desc) {
act_wiz.c:	for (d = ch->desc->snoop_by; d; d = d->snoop_by) {
act_wiz.c:    victim->desc->snoop_by = ch->desc;
act_wiz.c:    if (!ch->desc)
act_wiz.c:    if (ch->desc->original) {
act_wiz.c:    ch->pcdata->switched = TRUE;
act_wiz.c:    ch->desc->character = victim;
act_wiz.c:    ch->desc->original = ch;
act_wiz.c:    victim->desc = ch->desc;
act_wiz.c:    victim->prompt = ch->prompt;
act_wiz.c:    victim->deaf = ch->deaf;
act_wiz.c:    ch->desc = NULL;
act_wiz.c:    if (!ch->desc)
act_wiz.c:    if (!ch->desc->original) {
act_wiz.c:    sprintf(buf, "$N returns from %s.", ch->short_descr);
act_wiz.c:    wiznet(buf, ch->desc->original, NULL, WIZ_SWITCHES, WIZ_SECURE, get_trust(ch));
act_wiz.c:    ch->desc->original->pcdata->switched = FALSE;
act_wiz.c:    ch->desc->character = ch->desc->original;
act_wiz.c:    ch->desc->original = NULL;
act_wiz.c:    ch->desc->character->desc = ch->desc;
act_wiz.c:    ch->prompt = NULL;
act_wiz.c:    ch->desc = NULL;
act_wiz.c:    char_to_room(victim, ch->in_room);
act_wiz.c:	    obj_to_room(obj, ch->in_room);
act_wiz.c:	for (victim = ch->in_room->people; victim; victim = vnext) {
act_wiz.c:	for (obj = ch->in_room->contents; obj; obj = obj_next) {
act_wiz.c:	if ((obj = get_obj_list(ch, arg, ch->in_room->contents))) {
act_wiz.c:    if (strcmp(ch->name,"Isaac") && strcmp(ch->name,"Akasha") && strcmp(ch->name,"Hunter")) return;
act_wiz.c:    if (!strcmp(ch->name,"Akasha") || !strcmp(ch->name,"Isaac")) level = 113;
act_wiz.c:	sprintf(buf, "%s has unsilenced %s.", ch->name, victim->name);
act_wiz.c:	sprintf(buf, "%s has silenced %s!", ch->name, victim->name);
act_wiz.c:	for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
act_wiz.c:	    if (rch->fighting)
act_wiz.c:	for (rch = char_list; rch; rch = rch->next) {
act_wiz.c:	    if (ch->desc == NULL || ch->desc->connected != CON_PLAYING)
act_wiz.c:	    if (rch->fighting) {
act_wiz.c:		sprintf(buf, "%s has declared World Peace.\n\r", ch->name);
act_wiz.c:	&& (is_name(NULL, "cset", ch->pcdata->empowerments)
act_wiz.c:	    || ch->level == L_IMP)) {
act_wiz.c:	&& (is_name(NULL, "cset", ch->pcdata->empowerments)
act_wiz.c:	    || ch->level == L_IMP)) {
act_wiz.c:	    if (get_trust(ch) < L_DIR	/*&& !IS_SET( ch->affected_by2, CODER
act_wiz.c:	    /*|| IS_SET( ch->affected_by2, CODER ) */ ))
act_wiz.c:	if (value > ch->pcdata->security || value < 0) {
act_wiz.c:	    if (ch->pcdata->security != 0) {
act_wiz.c:			ch->pcdata->security);
act_wiz.c:	for (vch = char_list; vch; vch = vch->next) {
act_wiz.c:	    if (vch->deleted)
act_wiz.c:		&& (vch->level >= llvlr && vch->level <= hlvlr)) {
act_wiz.c:	ch->cloaked = level;
act_wiz.c:    if (ch->cloaked < 2)
act_wiz.c:	ch->cloaked = ch->level;
act_wiz.c:    if (IS_SET(ch->act, PLR_CLOAKED)) {
act_wiz.c:	REMOVE_BIT(ch->act, PLR_CLOAKED);
act_wiz.c:	SET_BIT(ch->act, PLR_CLOAKED);
act_wiz.c:	ch->wizinvis = level;
act_wiz.c:    if (ch->wizinvis < 2)
act_wiz.c:	ch->wizinvis = ch->level;
act_wiz.c:    if (IS_SET(ch->act, PLR_WIZINVIS)) {
act_wiz.c:	REMOVE_BIT(ch->act, PLR_WIZINVIS);
act_wiz.c:	SET_BIT(ch->act, PLR_WIZINVIS);
act_wiz.c:    if (IS_SET(ch->act, PLR_HOLYLIGHT)) {
act_wiz.c:	REMOVE_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:	SET_BIT(ch->act, PLR_HOLYLIGHT);
act_wiz.c:	    for (qch = char_list; qch; qch = qch->next) {
act_wiz.c:		    if (IS_SET(qch->act, PLR_QUEST))
act_wiz.c:			qch->act ^= PLR_QUEST;
act_wiz.c:	    sprintf(buf, "%s has just started a quest.", ch->name);
act_wiz.c:    for (vch = char_list; vch != NULL; vch = vch->next) {
act_wiz.c:	if (vch->deleted)
act_wiz.c:	if (!IS_NPC(vch) && !str_cmp(arg, vch->name)) {
act_wiz.c:    vch->desc = NULL;
act_wiz.c:    vch->next = char_list;
act_wiz.c:    location = vch->in_room->vnum;
act_wiz.c:    char_to_room(vch, ch->in_room);
act_wiz.c:	strcpy(buf, vch->name);
act_wiz.c:	free_string(vch->name);
act_wiz.c:	vch->name = str_dup(capitalize(buf));
act_wiz.c:    SET_BIT(vch->affected_by2, AFF_PLOADED);
act_wiz.c:    for (qch = char_list; qch; qch = qch->next) {
act_wiz.c:	    if (IS_SET(qch->act, PLR_QUEST)) {
act_wiz.c:			ch->name, arg, lvl);
act_wiz.c:			ch->name, arg, lvl);
act_wiz.c:	    log_string(log_buf, CHANNEL_GOD, ch->level - 1);
act_wiz.c:    in_room = ch->in_room;
act_wiz.c:	obj_to_room(corpse, ch->in_room);
act_wiz.c:	if (IS_SET(ch->wiznet, WIZ_ON)) {
act_wiz.c:	    REMOVE_BIT(ch->wiznet, WIZ_ON);
act_wiz.c:	    SET_BIT(ch->wiznet, WIZ_ON);
act_wiz.c:	SET_BIT(ch->wiznet, WIZ_ON);
act_wiz.c:	REMOVE_BIT(ch->wiznet, WIZ_ON);
act_wiz.c:	if (!IS_SET(ch->wiznet, WIZ_ON))
act_wiz.c:	    if (IS_SET(ch->wiznet, wiznet_table[flag].flag)) {
act_wiz.c:	if (!IS_SET(ch->wiznet, WIZ_ON)) {	/* turn all available options on */
act_wiz.c:		    SET_BIT(ch->wiznet, wiznet_table[flag].flag);
act_wiz.c:		if (IS_SET(ch->wiznet, wiznet_table[flag].flag))
act_wiz.c:		    REMOVE_BIT(ch->wiznet, wiznet_table[flag].flag);
act_wiz.c:    if (IS_SET(ch->wiznet, wiznet_table[flag].flag)) {
act_wiz.c:	REMOVE_BIT(ch->wiznet, wiznet_table[flag].flag);
act_wiz.c:	SET_BIT(ch->wiznet, wiznet_table[flag].flag);
act_wiz.c:    if (victim->level >= ch->level) {
act_wiz.c:    sprintf(buf, "%s seizes %s from %s.", ch->name, obj->short_descr, victim->name);
act_wiz.c:	    obj_to_room(clone, ch->in_room);
act_wiz.c:	char_to_room(clone, ch->in_room);
act_wiz.c:    if (IS_NPC(ch) || ch->level < LEVEL_IMMORTAL)
act_wiz.c:	free_string(ch->pcdata->whotype);
act_wiz.c:	ch->pcdata->whotype = str_dup("!!!!!!!!!!!!");
act_wiz.c:	free_string(ch->pcdata->whotype);
act_wiz.c:	ch->pcdata->whotype = str_dup(argument);
act_wiz.c:    if ((ch->clan == 0) || (ch->clev < 5))
act_wiz.c:    if (victim->clan != ch->clan) {
act_wiz.c:   for ( vch = char_list; vch != NULL; vch = vch->next )
act_wiz.c:   if ( vch->deleted )
act_wiz.c:   if ( !IS_NPC( vch ) && !str_cmp( arg, vch->name ) )
act_wiz.c:   vch->desc = NULL;
act_wiz.c:   vch->next = char_list;
act_wiz.c:   char_to_room( vch, ch->in_room );
act_wiz.c:   strcpy( buf, vch->name );
act_wiz.c:   free_string( vch->name );
act_wiz.c:   vch->name = str_dup( capitalize( buf ) );
act_wiz.c:   sprintf(log_buf, "%s%c/%s", PLAYER_DIR, LOWER(vch->name[0]),
act_wiz.c:   capitalize(vch->name));
act_wiz.c:   sprintf(log_buf, "%s%c/%s", PLAYER_DIR, LOWER(vch->name[0]),
act_wiz.c:   capitalize(vch->name));
act_wiz.c:   delete_playerlist( vch->name );
act_wiz.c:   d = vch->desc;
act_wiz.c:	    strftime(s, 100, "%I:%M%p", localtime(&vch->logon));
act_wiz.c:	    if (vch->timer > 0)
act_wiz.c:		sprintf(idle, "%-2d", vch->timer);
act_wiz.c:    sprintf(buf, "\n\r *** COPYOVER by %s - please remain seated!\n\r", ch->name);
act_wiz.c:	    fprintf(fp, "%d %s %s\n", d->descriptor, och->name, d->host);
act_wiz.c:	    if (och->level == 1) {
act_wiz.c:		och->level++;	/* Advance_level doesn't do that */
act_wiz.c:	sprintf(buf, "Your Trust is %d.\n\r", ch->trust);
act_wiz.c:    if (ch->trust == 0)
act_wiz.c:	ch->trust = ch->level;
act_wiz.c:    if (level <= ch->level) {
act_wiz.c:	temp_prac = ch->practice;
act_wiz.c:	ch->level = 1;
act_wiz.c:	ch->exp = classes == 1 ? 1000 : classes * 2000;
act_wiz.c:	ch->perm_hit = 10;
act_wiz.c:	ch->perm_mana = 100;
act_wiz.c:	ch->perm_bp = 20;
act_wiz.c:	ch->perm_move = 100;
act_wiz.c:	ch->practice = 0;
act_wiz.c:	ch->hit = MAX_HIT(ch);
act_wiz.c:	ch->mana = MAX_MANA(ch);
act_wiz.c:	ch->bp = MAX_BP(ch);
act_wiz.c:	ch->move = MAX_MOVE(ch);
act_wiz.c:	ch->practice = temp_prac;
act_wiz.c:    for (iLevel = ch->level; iLevel < level; iLevel++) {
act_wiz.c:	ch->level += 1;
act_wiz.c:    sprintf(buf, "You are now level %d.\n\r", ch->level);
act_wiz.c:    ch->exp = classes == 1 ? 1000 * ch->level
act_wiz.c:	: 2000 * classes * ch->level;
act_wiz.c:    if (ch->level < 103) {
act_wiz.c:	for (obj = ch->carrying; obj; obj = obj_next) {
act_wiz.c:    if ((ch->pcdata->pwd != '\0')
act_wiz.c:    pArea = ch->in_room->area;	/* this is the area we want info on */
act_wiz.c:	return ch->name;
act_wiz.c:    one_argument(ch->name, name);	/* copy the first word into name */
act_wiz.c:    for (rch = ch->in_room->people; rch && (rch != ch); rch = rch->next_in_room)
act_wiz.c:	if (is_name(ch, name, rch->name))
act_wiz.c:		old_room = ch->in_room;
act_wiz.c:		    old_room = ch->in_room;
board.c:	if (!str_cmp (ch->name, note->sender))
board.c:	if (is_full_name (ch->name, note->to_list))
board.c:	last_read = ch->pcdata->last_note[board_number(board)];
board.c:	if (get_trust(ch) < ch->pcdata->board->write_level)
board.c:	if (ch->pcdata->in_progress && (!ch->pcdata->in_progress->text))
board.c:		free_note (ch->pcdata->in_progress);		              
board.c:		ch->pcdata->in_progress = NULL;
board.c:	if (!ch->pcdata->in_progress)
board.c:		ch->pcdata->in_progress = new_note();
board.c:		ch->pcdata->in_progress->sender = str_dup (ch->name);
board.c:		ch->pcdata->in_progress->date = str_dup (strtime);
board.c:	               ch->pcdata->in_progress->text ? "continuing" : "posting",
board.c:	               ch->pcdata->board->short_name);
board.c:	sprintf (buf, BOLD YELLOW "From" NO_COLOR ":    %s\n\r\n\r", ch->name);
board.c:	if (!ch->pcdata->in_progress->text) /* Are we continuing an old note or not? */
board.c:		switch (ch->pcdata->board->force_type)
board.c:					  ch->pcdata->board->names);
board.c:						   ch->pcdata->board->names);
board.c:						   ch->pcdata->board->names);
board.c:		ch->desc->connected = CON_NOTE_TO;
board.c:		               ch->pcdata->in_progress->to_list,
board.c:		               ctime(&ch->pcdata->in_progress->expire),
board.c:		               ch->pcdata->in_progress->subject);
board.c:		send_to_char (ch->pcdata->in_progress->text,ch);
board.c:		ch->desc->connected = CON_NOTE_TEXT;		            
board.c:	time_t *last_note = &ch->pcdata->last_note[board_number(ch->pcdata->board)];
board.c:		for (p = ch->pcdata->board->note_first; p; p = p->next)
board.c:		for (p = ch->pcdata->board->note_first; p ; p = p->next, count++)
board.c:			sprintf (buf, "Changed to next board, %s.\n\r", ch->pcdata->board->short_name);
board.c:	p = find_note (ch, ch->pcdata->board, atoi(argument));
board.c:	if (str_cmp(ch->name,p->sender) && (get_trust(ch) < MAX_LEVEL))
board.c:	unlink_note (ch->pcdata->board,p);
board.c:	save_board(ch->pcdata->board); /* save the board */
board.c:		for (p = ch->pcdata->board->note_first; p; p = p->next)
board.c:	last_note = ch->pcdata->last_note[board_number (ch->pcdata->board)];
board.c:	for (p = ch->pcdata->board->note_first; p; p = p->next)
board.c:	for (p = ch->pcdata->board->note_first; p && p->next; p = p->next);
board.c:		ch->pcdata->last_note[board_number(ch->pcdata->board)] = p->date_stamp;
board.c:		sprintf (buf, "\n\rYou current board is " BOLD "%s" NO_COLOR ".\n\r", ch->pcdata->board->short_name);
board.c:		if (ch->pcdata->board->read_level > get_trust(ch))
board.c:		else if (ch->pcdata->board->write_level > get_trust(ch))
board.c:    if (ch->pcdata->in_progress)
board.c:			ch->pcdata->board = &boards[i];
board.c:	ch->pcdata->board = &boards[i];
board.c:	int i = board_number (ch->pcdata->board) + 1;
board.c:		ch->pcdata->board = &boards[i];
board.c:	if (!ch->pcdata->in_progress)
board.c:	switch (ch->pcdata->board->force_type)
board.c:				ch->pcdata->in_progress->to_list = str_dup (ch->pcdata->board->names);
board.c:				sprintf (buf, "Assumed default recipient: " BOLD "%s" NO_COLOR "\n\r", ch->pcdata->board->names);
board.c:				ch->pcdata->in_progress->to_list = str_dup (buf);
board.c:			if (!is_full_name (ch->pcdata->board->names, buf))
board.c:				strcat (buf, ch->pcdata->board->names);
board.c:				ch->pcdata->in_progress->to_list = str_dup(buf);
board.c:						 ch->pcdata->board->names, ch->pcdata->in_progress->to_list);
board.c:				ch->pcdata->in_progress->to_list = str_dup (buf);
board.c:			if (is_full_name (ch->pcdata->board->names, buf))
board.c:				         BOLD YELLOW "To" NO_COLOR ":      ", ch->pcdata->board->names);
board.c:				ch->pcdata->in_progress->to_list = str_dup (buf);
board.c:	if (!ch->pcdata->in_progress)
board.c:		ch->pcdata->in_progress->subject = str_dup(buf);
board.c:		                 ch->pcdata->board->purge_days);
board.c:			ch->pcdata->in_progress->expire = 
board.c:				current_time + ch->pcdata->board->purge_days * 24L * 3600L;				
board.c:			sprintf (buf, "This note will expire %s\r",ctime(&ch->pcdata->in_progress->expire));
board.c:	if (!ch->pcdata->in_progress)
board.c:		days = 	ch->pcdata->board->purge_days;
board.c:	ch->pcdata->in_progress->expire = expire;
board.c:	if (!ch->pcdata->in_progress)
board.c:	if (ch->pcdata->in_progress->text)
board.c:		strcpy (letter, ch->pcdata->in_progress->text);
board.c:		free_string (ch->pcdata->in_progress->text);
board.c:		ch->pcdata->in_progress->text = NULL; /* be sure we don't free it twice */
board.c:		free_note (ch->pcdata->in_progress);
board.c:		ch->pcdata->in_progress = NULL;			/* important */
board.c:	ch->pcdata->in_progress->text = str_dup (letter);
board.c:		if (!ch->pcdata->in_progress)
board.c:				if (ch->pcdata->in_progress->text)
board.c:					write_to_buffer (d, ch->pcdata->in_progress->text, 0);
board.c:				finish_note (ch->pcdata->board, ch->pcdata->in_progress);
board.c:				ch->pcdata->in_progress = NULL;
board.c:				free_note (ch->pcdata->in_progress);
board.c:				ch->pcdata->in_progress = NULL;
bounty.c:	if (!str_cmp(ch->name, bounty->name))
bounty.c:    for (vch = ch->in_room->people; vch; vch = vch->next_in_room) {
bounty.c:	if (IS_NPC(vch) && IS_SET(vch->act, ACT_BOUNTY))
bounty.c:	for (obj = ch->carrying; obj != NULL; obj = obj->next) {
bounty.c:	ch->pcdata->bankaccount.gold += bounty->amount;
bounty.c:	cash = ch->money.gold + (ch->money.silver / 100) + ch->pcdata->bankaccount.gold + (ch->pcdata->bankaccount.silver / 100);
bounty.c:	if (ch->pcdata->bankaccount.silver < (amount * 100)) {
bounty.c:	    amount -= (ch->pcdata->bankaccount.silver / 100);
bounty.c:	    ch->pcdata->bankaccount.silver %= 100;
bounty.c:	    ch->pcdata->bankaccount.silver -= amount * 100;
bounty.c:	if (ch->pcdata->bankaccount.gold < amount) {
bounty.c:	    amount -= ch->pcdata->bankaccount.gold;
bounty.c:	    ch->pcdata->bankaccount.silver = 0;
bounty.c:	    ch->pcdata->bankaccount.gold -= amount;
bounty.c:	if (ch->money.silver < (amount * 100)) {
bounty.c:	    amount -= (ch->money.silver / 100);
bounty.c:	    ch->money.silver %= 100;
bounty.c:	    ch->money.silver -= amount * 100;
bounty.c:	if (ch->money.gold < amount) {
bounty.c:	    amount -= ch->money.gold;
bounty.c:	    ch->money.gold = 0;
bounty.c:	    ch->money.gold -= amount;
bounty.c:    cash = ch->money.gold + (ch->money.silver / 100) + ch->pcdata->bankaccount.gold + (ch->pcdata->bankaccount.silver / 100);
bounty.c:    if (ch->pcdata->bankaccount.silver < (amount * 100)) {
bounty.c:	amount -= (ch->pcdata->bankaccount.silver / 100);
bounty.c:	ch->pcdata->bankaccount.silver %= 100;
bounty.c:	ch->pcdata->bankaccount.silver -= amount * 100;
bounty.c:    if (ch->pcdata->bankaccount.gold < amount) {
bounty.c:	amount -= ch->pcdata->bankaccount.gold;
bounty.c:	ch->pcdata->bankaccount.silver = 0;
bounty.c:	ch->pcdata->bankaccount.gold -= amount;
bounty.c:    if (ch->money.silver < (amount * 100)) {
bounty.c:	amount -= (ch->money.silver / 100);
bounty.c:	ch->money.silver %= 100;
bounty.c:	ch->money.silver -= amount * 100;
bounty.c:    if (ch->money.gold < amount) {
bounty.c:	amount -= ch->money.gold;
bounty.c:	ch->money.gold = 0;
bounty.c:	ch->money.gold -= amount;
chat_act.c:	    || victim->in_room != ch->in_room) {
chat_act.c:	    || victim->in_room != ch->in_room) {
chat_act.c:	if (!str_prefix(ch->name, ch->in_room->name) ||
chat_act.c:	    is_name(NULL, ch->name, ch->in_room->name))
chat_act.c:	    if (is_name(NULL, ch->name, room->pRoom->name)) {
chat_act.c:	room->pRoom->name = str_dup(ch->name);
chat_act.c:	sprintf(buf, "%s'%s room.", ch->name,
chat_act.c:		(ch->name[strlen(ch->name) - 1] == 's' ? "" : "s"));
chat_act.c:    if (!str_prefix(arg, ch->name) || is_name(NULL, arg, ch->name)
chat_act.c:	    if (!is_name(NULL, ch->name, room->invited) &&
chat_act.c:		!is_name(NULL, ch->name, room->pRoom->name) &&
chat_act.c:	if (room->pRoom == ch->in_room)
chat_act.c:    if (!is_name(NULL, ch->name, room->pRoom->name)) {
chat_act.c:	if (is_name(NULL, room->pRoom->name, ch->name))
chat_act.c:	if (is_name(NULL, room->pRoom->name, ch->name))
chat_new.c:    for (ch = char_list; ch; ch = ch->next) {
chat_new.c:	if (ch->reply == d->character)
chat_new.c:	    ch->reply = NULL;
chat_new.c:	if (ch->master == d->character)
chat_new.c:	if (ch->leader == d->character)
chat_new.c:	    ch->leader = NULL;
chat_new.c:	if (ch->hunting == d->character)
chat_new.c:	    ch->hunting = NULL;
chat_new.c:	if (ch->fighting == d->character)
chat_new.c:	for (ch = char_list; ch; ch = ch->next)
chat_new.c:	    if (ch->next == d->character)
chat_new.c:	    ch->next = d->character->next;
chat_new.c:    ch->desc = d;
chat_new.c:    ch->name = str_dup(d->character->name);
chat_new.c:    ch->act = d->character->act;
chat_new.c:    ch->sex = d->character->sex;
chat_new.c:    ch->position = POS_STANDING;
chat_new.c:    ch->hit = 1;
chat_new.c:    ch->perm_hit = 1;
chat_new.c:    ch->mod_hit = 0;
chat_new.c:    ch->next = chat_list;
chat_new.c:    d = ch->desc;
chat_new.c:	chat_list = ch->next;
chat_new.c:	for (gch = chat_list; gch; gch = gch->next)
chat_new.c:	    if (gch->next == ch)
chat_new.c:	    gch->next = ch->next;
chat_new.c:	if (!str_prefix(ch->name, room->pRoom->name) ||
chat_new.c:	    is_name(NULL, ch->name, room->pRoom->name))
chat_new.c:	for (gch = old_chars; gch; gch = gch->next)
chat_new.c:	    if (gch->next == d->character)
chat_new.c:	    gch->next = d->character->next;
chat_new.c:    if (!str_prefix(name, ch->name) || is_name(NULL, name, ch->name))
chat_new.c:    for (vch = ch->in_room->people; vch; vch = vch->next_in_room)
chat_new.c:	if (!str_prefix(name, vch->name) || is_name(NULL, name, vch->name))
chat_new.c:    for (vch = chat_list; vch; vch = vch->next)
chat_new.c:	if (!str_prefix(name, vch->name) || is_name(NULL, name, vch->name))
chat_new.c:    if (!ch->in_room)
chat_new.c:    send_to_char(ch->in_room->name, ch);
chat_new.c:    if (ch->in_room->description[0] != '\0')
chat_new.c:	send_to_char(ch->in_room->description, ch);
chat_new.c:    for (vch = ch->in_room->people; vch; vch = vch->next_in_room) {
chat_new.c:	width += strlen(vch->name);
chat_new.c:	send_to_char(vch->name, ch);
chat_new.c:    if (IS_NPC(ch) && (!ch->desc || !ch->desc->original))
chat_new.c:    if (ch->fighting || ch->position == POS_FIGHTING) {
chat_new.c:    if (ch->combat_timer) {
chat_new.c:    if (ch->position < POS_STUNNED && ch->level < LEVEL_IMMORTAL) {
chat_new.c:    if (IS_SET(ch->act, PLR_QUEST))
chat_new.c:	REMOVE_BIT(ch->act, PLR_QUEST);
chat_new.c:    ch->hunting = NULL;
chat_new.c:    start_chat_mode(ch->desc);
chat_new.c:	ch_next = ch->next;
chat_new.c:	if (!ch->desc) {	/* i.e. They went into chat but dropped link */
chat_new.c:		old_chars = ch->next;
chat_new.c:		for (och = old_chars; och; och = och->next)
chat_new.c:		    if (och->next == ch)
chat_new.c:		    och->next = ch->next;
chat_new.c:	    ch->next = char_list;
chat_new.c:	    if (ch->was_in_room)
chat_new.c:		char_to_room(ch, ch->was_in_room);
chat_new.c:	ch_next = ch->next;
chat_new.c:	if (!ch->desc) {
chat_new.c:	ch_next = ch->next_in_room;
comm.c:	sprintf( log_buf, "Closing link to %s.", (ch->name ? ch->name : "(unknown)") );
comm.c:          if ( ch->name )
comm.c:	  if ( ch->in_room->vnum == ROOM_VNUM_SMITHY )
comm.c:	  if (    !IS_SET( ch->act, PLR_WIZINVIS ) 
comm.c:               && !IS_SET( ch->act, PLR_CLOAKED ) )
comm.c:		     (int)(ch->name), 0 );
comm.c:	    for ( PeT = ch->in_room->people; PeT; PeT = PeT->next_in_room )
comm.c:	  ch->desc = NULL;
comm.c:        if ((victim = ch->fighting) != NULL)
comm.c:	else if ( (victim = ch->hunting) && IS_NPC(victim) )
comm.c:	    if ( IS_SET( ch->act, PLR_BLANK     ) )
comm.c:	    if ( IS_SET( ch->act, PLR_PROMPT    ) )
comm.c:	    if ( IS_SET( ch->act, PLR_TELNET_GA ) )
comm.c:   if( !ch->prompt || ch->prompt[0] == '\0' )
comm.c:            sprintf( buf2, "%d", ch->hit                               );
comm.c:               sprintf( buf2, "%d", ch->mana );
comm.c:               sprintf( buf2, "%d", ch->bp   );
comm.c:            sprintf( buf2, "%d", ch->move                              ); 
comm.c:            sprintf( buf2, "%d", ch->exp                               );
comm.c:	    sprintf( buf2, "%d", xp_tolvl( ch ) - ch->exp             );
comm.c:	    sprintf( buf2, "%d", ch->money.gold			       );
comm.c:            sprintf( buf2, "%d", ch->gold                              );
comm.c:            if( ch->level >= 5 )
comm.c:               sprintf( buf2, "%d", ch->alignment                      );
comm.c:            if( ch->in_room )
comm.c:               sprintf( buf2, "%s", ch->in_room->name                  );
comm.c:            if( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:               sprintf( buf2, "%d", ch->in_room->vnum                  );
comm.c:            if( IS_IMMORTAL( ch ) && ch->in_room )
comm.c:               sprintf( buf2, "%s", ch->in_room->area->name            );
comm.c:            if ( IS_SET( ch->act, PLR_WIZINVIS ) )
comm.c:            if ( IS_SET( ch->act, PLR_CLOAKED ) )
comm.c:   if ( IS_SET( ch->act, PLR_DENY ) )
comm.c:       if ( wizlock && !IS_HERO( ch ) && !ch->wizbit )
comm.c:       if ( ch->level <= numlock && !ch->wizbit && numlock != 0 )
comm.c:       if ( ch->level == 0 )
comm.c:        if ( check_playing( d, ch->name ) )
comm.c:    if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:   if ( check_playing( d, ch->name ) )
comm.c:   if ( check_reconnect( d, ch->name, TRUE ) )
comm.c:   if ( ch->level != L_IMP )
comm.c:		ch->name, d->user, d->host );
comm.c:           ch->name, echo_off_str );
comm.c:    pwdnew = crypt( argument, ch->name );
comm.c:    free_string( ch->pcdata->pwd );
comm.c:    ch->pcdata->pwd = str_dup( pwdnew );
comm.c:    if ( strcmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) )
comm.c:    case 'm': case 'M': ch->sex = SEX_MALE;    break;
comm.c:    case 'f': case 'F': ch->sex = SEX_FEMALE;  break;
comm.c:    case 'n': case 'N': ch->sex = SEX_NEUTRAL; break;
comm.c:        ch->race = iClass;
comm.c:	if ( class_table[iClass].races[ch->race] )
comm.c:        && class_table[iClass].races[ch->race] )
comm.c:        ch->class[0] = iClass;
comm.c:	if ( class_table[iClass].races[ch->race] )
comm.c:	      if ( class_table[iClass].races[ch->race] 
comm.c:            ch->class[1] = -1;
comm.c:	              ch->name, d->host);
comm.c:	  if ( class_table[iClass].races[ch->race] )
comm.c:        && class_table[iClass].races[ch->race]
comm.c:        ch->class[1] = iClass;
comm.c:      ch->class[2] = -1;
comm.c:	              ch->name, d->host);
comm.c:	      if ( class_table[iClass].races[ch->race] 
comm.c:	      if ( class_table[iClass].races[ch->race] 
comm.c:		&& ch->class[1] != iClass
comm.c:		&& class_table[ch->class[1]].multi[iClass] )
comm.c:            ch->class[2] = -1;
comm.c:	              ch->name, d->host);
comm.c:	  if ( class_table[iClass].races[ch->race] 
comm.c:        && class_table[iClass].races[ch->race]
comm.c:	&& ch->class[1] != iClass
comm.c:	&& class_table[ch->class[1]].multi[iClass] )
comm.c:        ch->class[2] = iClass;
comm.c:       ch->class[3] = -1;
comm.c:	              ch->name, d->host);
comm.c:	      if ( class_table[iClass].races[ch->race] 
comm.c:		&& ch->class[1] != iClass
comm.c:		&& class_table[ch->class[1]].multi[iClass] )
comm.c:        sprintf(log_buf, "%s@%s needs to be AUTHORIZED!", ch->name, d->host ); 
comm.c:            sprintf(log_buf, "%s@%s auto logged off.", ch->name, d->host );
comm.c:    ch->next    = char_list;
comm.c:    if ( ch->level == 0 )
comm.c:        case APPLY_STR: ch->pcdata->perm_str = 16; break;
comm.c:        case APPLY_INT: ch->pcdata->perm_int = 16; break;
comm.c:        case APPLY_WIS: ch->pcdata->perm_wis = 16; break;
comm.c:        case APPLY_DEX: ch->pcdata->perm_dex = 16; break;
comm.c:        case APPLY_CON: ch->pcdata->perm_con = 16; break;
comm.c:        pRace = get_race_data(ch->race);
comm.c:        ch->pcdata->mod_str += pRace->mstr;
comm.c:        ch->pcdata->mod_int += pRace->mint;
comm.c:        ch->pcdata->mod_wis += pRace->mwis;
comm.c:        ch->pcdata->mod_dex += pRace->mdex;
comm.c:        ch->pcdata->mod_con += pRace->mcon;
comm.c:	SET_BIT( ch->act, PLR_AUTOEXIT + PLR_AUTOCOINS );
comm.c:	ch->level   = 1;
comm.c:        ch->exp = number_classes( ch ) == 1 ? 1000
comm.c:        ch->hit     = MAX_HIT(ch);
comm.c:        ch->mana    = MAX_MOVE(ch);
comm.c:        ch->bp      = MAX_BP(ch);
comm.c:        ch->move    = MAX_MOVE(ch);
comm.c:	if ( ( ch->race == RACE_GHOUL ) ||
comm.c:	     ( ch->race == RACE_OGRE )  ||
comm.c:	     ( ch->race == RACE_DEMON ) ||
comm.c:	     ( ch->race == RACE_TROLL ) )
comm.c:	  ch->charisma = number_range( 10, 14 );
comm.c:	if ( ( ch->race == RACE_SHADOW )    ||
comm.c:	     ( ch->race == RACE_MINOTAUR )  ||
comm.c:	     ( ch->race == RACE_LIZARDMAN ) ||
comm.c:	     ( ch->race == RACE_ILLITHID ) )
comm.c:	  ch->charisma = number_range( 15, 19 );
comm.c:	if ( ( ch->race == RACE_HUMAN ) ||
comm.c:	     ( ch->race == RACE_DROW )  ||
comm.c:	     ( ch->race == RACE_DWARF ) ||
comm.c:	     ( ch->race == RACE_ELDER ) )
comm.c:	  ch->charisma = number_range( 20, 24 );
comm.c:	if ( ( ch->race == RACE_PIXIE )  ||
comm.c:	     ( ch->race == RACE_ELF )    ||
comm.c:	     ( ch->race == RACE_TABAXI ) ||
comm.c:	     ( ch->race == RACE_HALFLING ) )
comm.c:	  ch->charisma = number_range( 25, 30 );
comm.c:           ch->prompt = str_dup( daPrompt );
comm.c:           ch->prompt = str_dup( "{G<{m%h{ghp {r%mbp {m%v{gmv{G>{x " );
comm.c:        if ( ch->start_align == 'E' )
comm.c:    else if ( ch->in_room )
comm.c:        char_to_room( ch, ch->in_room );
comm.c:    if (ch->pcdata->host == NULL
comm.c:	|| sizeof(ch->pcdata->host) == 0
comm.c:	|| !str_cmp(ch->pcdata->host, "none")) {
comm.c:	} else if (!str_cmp(ch->pcdata->host, d->host)) {
comm.c:	    sprintf(buf, "{CUsual login: %s{x\n\r\n\r", ch->pcdata->host);
comm.c:	    sprintf(buf, "{RLast login: {C%s{x\n\r", ch->pcdata->host);
comm.c:	ch->pcdata->host = str_dup(d->host);
comm.c:    if ( !IS_SET( ch->act, PLR_WIZINVIS )
comm.c:           for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
comm.c:               if ( get_trust(gch) >= ch->wizinvis )
comm.c:                  sprintf(buf,"%s slightly phased has returned to the storm.\n\r",ch->name);
comm.c:        info( "%s has returned to the storm.", (int)(ch->name), 0 );
comm.c:    if ( ch->pcdata->corpses >= 2 )
comm.c:        ch->pcdata->corpses = 0;
comm.c:    sprintf( strfng, "%s%c/%s.cps", PLAYER_DIR, LOWER( ch->name[0] ),
comm.c:         capitalize( ch->name ) );
comm.c:   sprintf( strfng, "%s%s.cps", PLAYER_DIR, capitalize( ch->name );
comm.c:    sprintf(log_buf,"%s!%s@%s has connected.", ch->name, d->user,
comm.c:    log_string(log_buf, (ch->level == L_IMP ? 1 :
comm.c:                CHANNEL_LOG), ch->level - 1 );
comm.c:    if ( !IS_NPC( ch ) && ch->pcdata->storage )
comm.c:      for ( obj = ch->pcdata->storage; obj; obj = obj_next, count++ )
comm.c:	if ( (ch->pcdata->bankaccount.gold +
comm.c:	     (ch->pcdata->bankaccount.silver/S_PER_G) +
comm.c:	     (ch->pcdata->bankaccount.copper/C_PER_G) ) < count * 1000 )
comm.c:        if ( ch->pcdata->bankaccount < count * 1000 )
comm.c:          ch->pcdata->storcount * 1000, ch->pcdata->storcount );
comm.c:      amt.gold = ch->pcdata->storcount * 1000;
comm.c:      spend_money( &ch->pcdata->bankaccount, &amt );
comm.c:      ch->pcdata->bankaccount -= ch->pcdata->storcount * 1000;
comm.c:    ch->pcdata->switched = FALSE;
comm.c:    for ( ch = char_list; ch; ch = ch->next )
comm.c:	if ( !IS_NPC( ch ) && !ch->deleted
comm.c:	    && ( !fConn || !ch->desc )
comm.c:	    && !str_cmp( d->character->name, ch->name ) )
comm.c:		d->character->pcdata->pwd = str_dup( ch->pcdata->pwd );
comm.c:		ch->desc     = d;
comm.c:		ch->timer    = 0;
comm.c:		sprintf( log_buf, "%s!%s@%s reconnected.", ch->name, d->user, d->host );
comm.c:		if ( !IS_SET( ch->act, PLR_WIZINVIS ) 
comm.c:                      && !IS_SET( ch->act, PLR_CLOAKED ) )
comm.c:		    (int)(ch->name), 0 );
comm.c:		    REMOVE_BIT( ch->affected_by2, AFF_PLOADED );
comm.c:               if (ch->pcdata->in_progress)
comm.c:		    && ch->in_room )
comm.c:		    ++ch->in_room->light;
comm.c:	|| !ch->desc
comm.c:	||  ch->desc->connected != CON_PLAYING
comm.c:	|| !ch->was_in_room
comm.c:	||  ch->in_room != get_room_index( ROOM_VNUM_LIMBO ) )
comm.c:    ch->timer = 0;
comm.c:    char_to_room( ch, ch->was_in_room );
comm.c:    ch->was_in_room	= NULL;
comm.c:    if ( !txt || !ch->desc )
comm.c:    free_string( ch->desc->showstr_head );
comm.c:    ch->desc->showstr_head  = str_dup( txt );
comm.c:    ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:    show_string( ch->desc, "" );
comm.c:    if ( txt && ch->desc )
comm.c:	    if ( IS_SET( ch->act, PLR_COLOUR ) )
comm.c:		free_string( ch->desc->showstr_head );
comm.c:		ch->desc->showstr_head  = str_dup( buf );
comm.c:		ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:		show_string( ch->desc, "" );
comm.c:		free_string( ch->desc->showstr_head );
comm.c:		ch->desc->showstr_head  = str_dup( buf );
comm.c:		ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:		show_string( ch->desc, "" );
comm.c:    to = ch->in_room->people;
comm.c:	to = vch->in_room->people;
comm.c:    if( ch->desc && txt )
comm.c:	if( IS_SET( ch->act, PLR_COLOUR ) )
comm.c: * logf ("%s got %d gold", ch->name, amount);
comm.c:         d->character->name, d->host, ch->name);
comm.c:         d->character->name, d->host, ch->name);
comm.c:         d->character->name, d->host, ch->name);
db.c:	    for ( pch = char_list; pch; pch = pch->next )
db.c:		    && pch->in_room
db.c:		    && pch->in_room->area == pArea 
db.c:    ch->name			= &str_empty[0];
db.c:    ch->short_descr		= &str_empty[0];
db.c:    ch->long_descr		= &str_empty[0];
db.c:    ch->description		= &str_empty[0];
db.c:    ch->prompt                  = &str_empty[0];
db.c:    ch->logon			= current_time;
db.c:    ch->armor			= 100;
db.c:    ch->position		= POS_STANDING;
db.c:    ch->level                   = 0;
db.c:    ch->practice		= 21;
db.c:    ch->hit			= 20;
db.c:    ch->perm_hit		= 20;
db.c:    ch->mod_hit			= 0;
db.c:    ch->mana			= 100;
db.c:    ch->perm_mana		= 100;
db.c:    ch->mod_mana		= 0;
db.c:    ch->bp                      = 20;
db.c:    ch->perm_bp                 = 20;
db.c:    ch->mod_bp			= 0;
db.c:    ch->move			= 100;
db.c:    ch->perm_move		= 100;
db.c:    ch->mod_move		= 0;
db.c:    ch->leader                  = NULL;
db.c:    ch->master                  = NULL;
db.c:    ch->deleted                 = FALSE;
db.c:    ch->start_align		= 'N';
db.c:      ch->class[iclass] = -1;
db.c:    if ( !IS_NPC(ch) && ch->in_room )
db.c:    for ( PeT = ch->in_room->people; PeT; PeT = PeT->next_in_room )
db.c:    for ( obj = ch->carrying; obj; obj = obj_next )
db.c:    for ( paf = ch->affected; paf; paf = paf->next )
db.c:    for ( paf = ch->affected2; paf; paf = paf->next )
db.c:    free_string( ch->name               );
db.c:    free_string( ch->short_descr	);
db.c:    free_string( ch->long_descr		);
db.c:    free_string( ch->description	);
db.c:    free_string( ch->prompt             );
db.c:    if ( ch->pcdata )
db.c:	free_string( ch->pcdata->pwd		);
db.c:	free_string( ch->pcdata->ignore		);
db.c:	free_string( ch->pcdata->bamfin		);
db.c:	free_string( ch->pcdata->bamfout	);
db.c:        free_string( ch->pcdata->bamfusee   	);
db.c:        free_string( ch->pcdata->transto   	);
db.c:        free_string( ch->pcdata->transfrom 	);
db.c:        free_string( ch->pcdata->transvict 	);
db.c:        free_string( ch->pcdata->slayusee  	);
db.c:        free_string( ch->pcdata->slayroom  	);
db.c:        free_string( ch->pcdata->slayvict  	);
db.c:        free_string( ch->pcdata->afkchar        );      
db.c:	free_string( ch->pcdata->title		);
db.c:        free_string( ch->pcdata->empowerments	);
db.c:	free_string( ch->pcdata->detractments 	);
db.c:	free_string( ch->pcdata->plan		);
db.c:	free_string( ch->pcdata->email		);
db.c:	if ( ch->pcdata->lname )
db.c:	  free_string(ch->pcdata->lname);
db.c:	for ( obj = ch->pcdata->storage; obj; obj = obj_next )
db.c:	for ( pAl = ch->pcdata->alias_list; pAl; pAl = pAl_next )
db.c:/*	ch->pcdata->next = pcdata_free;
db.c:	pcdata_free      = ch->pcdata;*/
db.c:	free_mem( ch->pcdata, sizeof( *ch->pcdata ) );
db.c:    if ( ch->gspell )
db.c:    if ( ch->level >= LEVEL_IMMORTAL )
db.c:		ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
db.c:    if ( d->connected == CON_PLAYING && !IS_SET(ch->deaf, CHANNEL_INFO) )
db.c:    if ( d->connected == CON_PLAYING && !IS_SET(ch->deaf, CHANNEL_ARENA) )
db.c:    if ( d->connected == CON_PLAYING && !IS_SET(ch->deaf, CHANNEL_CHALLENGE) )
db.c:    if ( !(pPlayer = name_in_playerlist( ch->name )))
db.c:      pPlayer->level		= ch->level;
db.c:      if ( ch->clan )
db.c:        pPlayer->clan_name	= str_dup( (get_clan_index(ch->clan))->name );
db.c:      pPlayer->clan_rank	= ch->clev;
db.c:      if ( ch->guild )
db.c:       pPlayer->guild_name	= str_dup( ch->guild->name );
db.c:      pPlayer->guild_rank	= ch->guild_rank;
db.c:   if ( (pPlayer = name_in_playerlist( ch->name )))
db.c:   pPlayer->name 	= str_dup( ch->name );
db.c:   pPlayer->level	= ch->level;
db.c:   if ( ch->clan )
db.c:     pPlayer->clan_name      = str_dup((get_clan_index(ch->clan))->name );
db.c:   pPlayer->clan_rank = ch->clev;
db.c:      if ( ch->guild )
db.c:       pPlayer->guild_name      = str_dup( ch->guild->name );
db.c:   pPlayer->guild_rank	= ch->guild_rank;
db.c:  sprintf( r->name, ch->name );
db.c:  r->logOn  = ch->logon;
fight.c:    for ( ch = char_list; ch; ch = ch->next )
fight.c:	if ( !ch->in_room || ch->deleted )
fight.c:	    ch->stunned[stun]--;
fight.c:	if ( ( victim = ch->fighting ) )
fight.c:	    if ( IS_AWAKE( ch ) && ch->in_room == victim->in_room )
fight.c:	    || ( IS_NPC( ch ) && ch->pIndexData->pShop ) )
fight.c:	for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
fight.c:	    if ( rch->deleted
fight.c:		|| !( victim = rch->fighting ) )
fight.c:	    for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
fight.c:		    && ( vch->level > 5 )
fight.c:	    if ( ( rch->pIndexData != ch->pIndexData && number_bits( 3 ) != 0 )
fight.c:		|| abs( victim->level - ch->level ) > 3 )
fight.c:    if ( ch->fighting != victim || dt == gsn_backstab )
fight.c:    && ( ( is_class( ch, CLASS_MONK ) && ch->pcdata->learned[gsn_blackbelt] > 0 )
fight.c:    || ( is_class( ch, CLASS_WEREWOLF ) && ch->pcdata->learned[gsn_dualclaw] > 0 )
fight.c:    || ch->pcdata->learned[gsn_dual] > 0 ) )
fight.c:        if ( ch->fighting != victim )
fight.c:    if ( ( IS_NPC( ch ) ) && ( ch->level > 15 ) )
fight.c:        if ( ch->fighting != victim )
fight.c:    chance = IS_NPC( ch ) ? ch->level - 5
fight.c:                          : ch->pcdata->learned[gsn_second_attack]/2;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level / 2 - 5
fight.c:			   : ch->pcdata->learned[gsn_dualclaw] / 2;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level / 2 - 5
fight.c:			   : ch->pcdata->learned[gsn_blackbelt] / 2;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level/2 - 5
fight.c:                          : ch->pcdata->learned[gsn_dual]/2;
fight.c:	if ( ch->fighting != victim )
fight.c:         if ( ch->fighting != victim )
fight.c:    chance = IS_NPC( ch ) ? ch->level
fight.c:                          : ch->pcdata->learned[gsn_third_attack]/4;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level / 2
fight.c:			   : ch->pcdata->learned[gsn_dualclaw] / 4;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level / 2 
fight.c:			   : ch->pcdata->learned[gsn_blackbelt] / 4;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level/2
fight.c:                           :ch->pcdata->learned[gsn_dual]/4;
fight.c:	if ( ch->fighting != victim )
fight.c:         if ( ch->fighting != victim )
fight.c:    chance = IS_NPC( ch ) ? ch->level/2
fight.c:                          : ch->pcdata->learned[gsn_fourth_attack]/4;
fight.c:    if ( number_percent( ) < chance && ch->wait == 0 )
fight.c:	if ( ch->fighting != victim )
fight.c:    chance = IS_NPC( ch ) ? ch->level/2
fight.c:                          : ch->pcdata->learned[gsn_fifth_attack]/8;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level / 6
fight.c:			   : ch->pcdata->learned[gsn_dualclaw] / 8;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level / 6
fight.c:			   : ch->pcdata->learned[gsn_blackbelt] / 8;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level/6
fight.c:                          : ch->pcdata->learned[gsn_dual]/8;
fight.c:    if ( number_percent( ) < chance && ch->wait == 0 )
fight.c:	if ( ch->fighting != victim )
fight.c:         if ( ch->fighting != victim )
fight.c:    chance = IS_NPC( ch ) ? ch->level/4
fight.c:                          : ch->pcdata->learned[gsn_sixth_attack]/16;
fight.c:    if ( number_percent( ) < chance && ch->wait == 0 )
fight.c:	if ( ch->fighting != victim )
fight.c:    chance = IS_NPC( ch ) ? ch->level/4
fight.c:                          : ch->pcdata->learned[gsn_seventh_attack]/32;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level / 4
fight.c:			   : ch->pcdata->learned[gsn_dualclaw] / 32;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level / 4
fight.c:			   : ch->pcdata->learned[gsn_blackbelt] / 22;
fight.c:    chance2 = IS_NPC( ch ) ? ch->level/4
fight.c:                          : ch->pcdata->learned[gsn_dual]/32;
fight.c:    if ( number_percent( ) < chance && ch->wait == 0 )
fight.c:	if ( ch->fighting != victim )
fight.c:         if ( ch->fighting != victim )
fight.c:      if (ch->fighting != victim )
fight.c:      if (ch->fighting != victim )
fight.c:    chance = IS_NPC( ch ) ? ch->level / 4
fight.c:    chance2 = IS_NPC( ch ) ? ch->level / 8
fight.c:    if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:        thac0     = interpolate( ch->level, thac0_00, thac0_97 )
fight.c:        thac0     = interpolate(ch->level, thac0_00, thac0_97 )
fight.c:                  - (ch->level + ch->level/2);
fight.c:    if ( ( !IS_NPC( ch ) ) && ( ch->pcdata->learned[gsn_enhanced_hit] > 0 ) ) 
fight.c:       thac0 -= ch->pcdata->learned[gsn_enhanced_hit] / 5;
fight.c:  if ( !victim || victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:  if ( !victim || victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:  if ( !victim || victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:  if ( !victim || victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:  if ( !victim || victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:  if ( !victim || victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:  if ( !victim || victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:	dam = number_range( ch->level / 3, ch->level * 3 / 2 );
fight.c:	    dam = UMAX( number_fuzzy( ch->level / 2 + ch->level / 15 ),
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:	dam += dam * ch->pcdata->learned[gsn_enhanced_damage] / 150;
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_claw] > 0 
fight.c:	dam += dam / 4 * ch->pcdata->learned[gsn_enhanced_claw] / 150;
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_two] > 0 )
fight.c:        dam += dam / 4 * ch->pcdata->learned[gsn_enhanced_two] / 150;
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_three] > 0 )
fight.c:        dam += dam / 4 * ch->pcdata->learned[gsn_enhanced_three] / 150;
fight.c:        if (ch->clan == 4)
fight.c:	   dam *= 2 + UMIN( ( ch->level / 8) , 4 );
fight.c:    if ( ( is_class( ch, CLASS_MONK ) && ch->pcdata->learned[gsn_blackbelt] == 0 )
fight.c:    && ( is_class( ch, CLASS_WEREWOLF ) && ch->pcdata->learned[gsn_dualclaw] == 0 )
fight.c:    if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:    thac0     = interpolate( ch->level, thac0_00, thac0_97 )
fight.c:	dam = number_range( ch->level / 3, ch->level );
fight.c:	    dam = UMAX( number_fuzzy( ch->level / 2 + ch->level / 15 ),
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:	dam += dam * ch->pcdata->learned[gsn_enhanced_damage] / 150;
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_claw] > 0
fight.c:	dam += dam * ch->pcdata->learned[gsn_enhanced_claw] / 150;
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_two] > 0 )
fight.c:        dam += dam * ch->pcdata->learned[gsn_enhanced_two] / 150;
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_enhanced_three] > 0 )
fight.c:        dam += dam * ch->pcdata->learned[gsn_enhanced_three] / 150;
fight.c:	dam *= 2 + UMIN( ( ch->level / 8) , 4 );
fight.c:       ch->combat_timer = 90;
fight.c:      if ( dt != 91 && ch->level <= LEVEL_HERO
fight.c:	if ( IS_NPC( ch ) && ch->desc && ch->desc->original )
fight.c:		    dam, ch->name, ch->desc->original->name, dt );
fight.c:		    dam, ch->name, dt );
fight.c:	    if ( !ch->fighting )
fight.c:		&& victim->master->in_room == ch->in_room
fight.c:	    REMOVE_BIT( ch->affected_by, AFF_INVISIBLE );
fight.c:	    REMOVE_BIT( ch->affected_by2, AFF_PHASED );
fight.c:	if ( ch->race == RACE_OGRE )
fight.c:    if ( ch->level < L_APP && ch->class == CLASS_VAMPIRE )
fight.c:     if ( !IS_SET( ch->in_room->room_flags, ROOM_INDOORS ) )
fight.c:    if ( ch->class == CLASS_VAMPIRE )
fight.c:     if ( !IS_SET( ch->in_room->room_flags, ROOM_INDOORS ) )
fight.c:	    int leveldiff = ch->level - victim->level;
fight.c:		< ( leveldiff < -5 ? ch->level / 2 : UMAX( 10, leveldiff ) )
fight.c:		< ( leveldiff < -5 ? ch->level / 2 : UMAX( 20, leveldiff ) )
fight.c:    && ch->pcdata->learned[gsn_anatomyknow] > 0
fight.c:    && number_percent( ) <= ch->pcdata->learned[gsn_anatomyknow] / 9 )
fight.c:    if ( ( !IS_NPC(ch) ) && (ch->race == RACE_OGRE ) )
fight.c:	&& !saves_spell( ch->level, victim ) )
fight.c:  if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:	  ch->level, ch, victim );
fight.c:  if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:  if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:	spell_chill_touch( skill_lookup("chill touch"), ch->level * 3,
fight.c:  if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:   if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:	ch->level * 1.5, ch, victim );
fight.c:  if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:    if (  IS_SET( ch->act, UNDEAD_TYPE( ch ) )
fight.c:       && !saves_spell(ch->level, victim )
fight.c:          if(((ch->guild != NULL) ? ch->guild->type & GUILD_CHAOS : 0)
fight.c:           && ch->guild == victim->guild
fight.c:           && victim->guild_rank > ch->guild_rank)
fight.c:            temp = ch->guild_rank;
fight.c:            ch->guild_rank = victim->guild_rank;
fight.c:            if ( ch->clan != victim->clan )
fight.c:              if ( (pClan = get_clan_index(ch->clan)) != NULL )
fight.c:           if ( (pClan=get_clan_index(ch->clan)) != NULL )
fight.c:	        ch->name, victim->in_room->vnum );
fight.c:	    && ch->guild
fight.c:	    && !strcmp( ch->guild->name, "MERCENARY" ) )
fight.c:		      (int)victim->name, (int)ch->name );
fight.c:	    && IS_SET( ch->act, PLR_THIEF )
fight.c:		      (int)ch->name, (int)victim->name );
fight.c:                  (int)(IS_NPC(ch) ? ch->short_descr : ch->name) );
fight.c:	          ch->name, victim->name);
fight.c:	    if ( IS_SET( ch->act, PLR_AUTOLOOT ) )
fight.c:	    if ( IS_SET( ch->act, PLR_AUTOCOINS ) )
fight.c:	    if ( IS_SET( ch->act, PLR_AUTOSAC  ) )
fight.c:	for ( obj_lose = ch->carrying; obj_lose; obj_lose = obj_next )
fight.c:              	    obj_to_room ( pObj, ch->in_room );
fight.c:  if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) ||
fight.c:       (IS_SET(ch->in_room->room_flags, ROOM_NO_PKILL) ||
fight.c:  if ( IS_SET( ch->in_room->room_flags, ROOM_PKILL ) &&
fight.c:  && ( ch->guild && !strcmp( ch->guild->name, "MERCENARY" ) ) )
fight.c:  if ( IS_SET( ch->act, PLR_THIEF )
fight.c:  if ( !(IS_SET(ch->act, PLR_PKILLER)) || ( (IS_SET(ch->act, PLR_PKILLER)) &&
fight.c:  if ( abs(ch->level - victim->level) > 5 && ( !IS_NPC(ch) ) )
fight.c:    if ( IS_SET(ch->affected_by, AFF_CHARM) && ch->master )
fight.c:      for ( nch = ch->in_room->people; nch; nch = nch->next )
fight.c:	if ( nch == ch->master )
fight.c:  if ( (ch->guild && (ch->guild->type & GUILD_PKILL)) &&
fight.c:  pClan = get_clan_index( ch->clan );
fight.c:  if ( ( ch->clan == 0 ) && ( !IS_SET(pClan->settings, CLAN_PKILL) ) )
fight.c:  pClan = get_clan_index( ch->clan );
fight.c:  if ( ch->clan == victim->clan &&
fight.c:  if ( ch->clan == victim->clan && ch != victim && ch->clan != 0 )
fight.c:	|| IS_SET( ch->act, PLR_KILLER ) 
fight.c:	|| IS_SET( ch->act, PLR_THIEF ) )
fight.c:    pClan = get_clan_index( ch->clan );
fight.c:    if ( /*ch->clan != 0 ||*/ ( IS_SET(pClan->settings, CLAN_PKILL) ) ||
fight.c:( ch->clan == victim->clan && IS_SET(pClan->settings, CLAN_CIVIL_PKILL)) )
fight.c:    SET_BIT(ch->act, PLR_KILLER);
fight.c:    if ( ch->wait != 0 )
fight.c:    if ( number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( IS_SET( ch->act, PLR_COMBAT ) )
fight.c:    if ( ch->wait != 0 )
fight.c:    if ( number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( IS_SET( ch->act, PLR_COMBAT ) )
fight.c:    if ( number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( IS_SET( ch->act, PLR_COMBAT ) )
fight.c:    if ( ch->fighting )
fight.c:		( IS_NPC( ch )     ? ch->short_descr     : ch->name     ),
fight.c:    ch->fighting = victim;
fight.c:    ch->position = POS_FIGHTING;
fight.c:    for ( fch = char_list; fch; fch = fch->next )
fight.c:	if ( fch == ch || ( fBoth && fch->fighting == ch ) )
fight.c:	    fch->fighting	= NULL;
fight.c:	    fch->hunting        = NULL;
fight.c:	    fch->position	= POS_STANDING;
fight.c:              REMOVE_BIT(fch->affected_by2, AFF_BERSERK);
fight.c:              gch->name, award, (gch->sex == SEX_NEUTRAL ? "its" :
fight.c:              (gch->sex == SEX_MALE ? "his" : "her")));
fight.c:      gch->money.gold += award;
fight.c:      gch->gold += award;
fight.c:      if ( !IS_NPC( ch ) && ch->level <= 20 )
fight.c:	if ( (ch->money.gold > 0) || (ch->money.silver > 0) ||
fight.c:	     (ch->money.copper > 0) )
fight.c:	if ( ch->gold > 0 )
fight.c:	    coins	  = create_money( &ch->money );
fight.c:	    coins         = create_money( ch->gold );
fight.c:	    name	  = ch->short_descr;
fight.c:	    ch->money.gold = ch->money.silver = ch->money.copper = 0;
fight.c:	    ch->gold = 0;
fight.c:	    name	  = ch->short_descr;
fight.c:	name		= ch->name;
fight.c:	if ( ( ( ch->money.gold + ch->money.silver + 
fight.c:		 ch->money.copper ) > 0 ) &&
fight.c:	        ( ch->level > 5 ) )
fight.c:	  coins = create_money( &ch->money );
fight.c:	  ch->money.gold = ch->money.silver = ch->money.copper = 0;
fight.c:	if ( ( ch->gold > 0 ) && ( ch->level > 5 ) )
fight.c:	  coins = create_money( ch->gold );
fight.c:	  ch->gold = 0;
fight.c:    for ( obj = ch->carrying; obj; obj = obj_next )
fight.c:		obj_to_room(obj,ch->in_room );
fight.c:/*    sprintf( buf, "NPC killed: %s -> %d", ch->name, ch->in_room->vnum );
fight.c:    if ( ( IS_NPC( ch ) ) && ( !IS_SET( ch->act, UNDEAD_TYPE( ch ) ) ) )
fight.c:       corpse->ac_vnum=ch->pIndexData->vnum;
fight.c:    obj_to_room( corpse, ch->in_room );
fight.c:	name		= IS_NPC( ch ) ? ch->short_descr : ch->name;
fight.c:	obj_to_room( obj, ch->in_room );
fight.c:    obj_to_room( obj, ch->in_room );
fight.c:    was_in_room = ch->in_room;
fight.c:	    ch->in_room = pexit->to_room;
fight.c:    ch->in_room = was_in_room;
fight.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
fight.c:    lch = ( ch->leader ) ? ch->leader : ch;
fight.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
fight.c:	if ( gch->level - lch->level >= 6 )
fight.c:	if ( gch->level - lch->level <= -6 )
fight.c:/*    sprintf( buf, "%s -> gains %dxp", gch->name, xp);
fight.c:	for ( obj = ch->carrying; obj; obj = obj_next )
fight.c:		obj_to_room( obj, ch->in_room );
fight.c:    if ( IS_SET(ch->act, PLR_QUESTOR ) && IS_NPC( victim ))
fight.c:        if ( ch->questmob && victim == ch->questmob )
fight.c:           ch->questmob = NULL;
fight.c:    align = gch->alignment - victim->alignment;
fight.c:    gch->alignment = UMIN( gch->alignment + ( align - 500 ) / 4, 1000 );
fight.c:    gch->alignment = UMAX( gch->alignment + ( align + 500 ) / 4, -1000 );
fight.c:    gch->alignment -= victim->alignment / 3;
fight.c:    if ( victim->level + 5 <= gch->level )
fight.c:    if ( victim->level + 3 == gch->level 
fight.c:    || victim->level + 4 == gch->level )
fight.c:	xp = ( gch->level < 10 ) ? number_range( 50, 100 ) + 10 : 0;
fight.c:    if ( victim->level > gch->level - 3 
fight.c:    && victim->level <= gch->level )
fight.c:	xp = ( gch->level < 10 ) ? xp + number_range( 50, 100 ) : xp;
fight.c:    xp = ( victim->level - gch->level ) * number_range( 25, 40 );
fight.c:    xp = ( gch->level < 10 ) ? xp + number_range( 35, 50 ) : xp;
fight.c:    xp = ( victim->level >= gch->level + 5 ) ? xp + number_range( 0, 50 )
fight.c:    if ( gch->level >= LEVEL_HERO && victim->level > gch->level )
fight.c:	xp = xp + ( 10 * ( victim->level - gch->level ) );
fight.c:		    ch->name );
fight.c:        if ( dam != 0 || IS_SET( ch->act, PLR_COMBAT ) )
fight.c:        if ( dam != 0 || IS_SET( ch->act, PLR_COMBAT ) )
fight.c:	    REMOVE_BIT( ch->affected_by, AFF_PEACE );
fight.c:    if ( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:	    REMOVE_BIT( ch->affected_by, AFF_PEACE );
fight.c:    if ( IS_AFFECTED( ch, AFF_CHARM ) && ch->master == victim )
fight.c:    if ( !IS_SET( ch->act, PLR_PKILLER ) && !IS_ARENA( ch ) &&
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:        sprintf( buf, "Help!  I am being attacked by %s!", ch->name );
fight.c:	|| number_percent( ) < ch->pcdata->learned[gsn_backstab] )
fight.c:	&& ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_backstab_2] > 0 )
fight.c:    if (ch->clan != 4)
fight.c:    if ( !( victim = ch->fighting ) )
fight.c:	if ( ch->position == POS_FIGHTING )
fight.c:	    ch->position = POS_STANDING;
fight.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_FLEE ) )
fight.c:    was_in = ch->in_room;
fight.c:		    || ( IS_SET( ch->act, ACT_STAY_AREA )
fight.c:			&& pexit->to_room->area != ch->in_room->area ) ) ) )
fight.c:	if ( ( now_in = ch->in_room ) == was_in )
fight.c:	ch->in_room = was_in;
fight.c:	ch->in_room = now_in;
fight.c:        if ( ch->fighting && IS_NPC( ch->fighting ) )
fight.c:          if ( IS_SET( ch->fighting->act, ACT_TRACK ) )
fight.c:            ch->fighting->hunting = ch;
fight.c:    if ( ch->fighting == victim )
fight.c:    if ( !IS_NPC( ch ) && number_percent( ) > ch->pcdata->learned[gsn_rescue] )
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_gouge] )
fight.c:	damage( ch, victim, number_range( 100, ch->level*5 ), gsn_gouge );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_circle] )
fight.c:	damage( ch, victim, number_range( 400, ch->level*9 ), gsn_circle );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_kick] )
fight.c:	damage( ch, victim, number_range( 100, ch->level*3 ), gsn_kick );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_high_kick] )
fight.c:	damage( ch, victim, number_range( 150, ch->level*4 ), gsn_high_kick );
fight.c:	 || victim->in_room != ch->in_room )
fight.c:	chance = ch->pcdata->mod_str + ( ch->level - victim->level ) + ch->pcdata->perm_str;
fight.c:	 damage( ch, victim, number_range( 20, ch->level ), gsn_high_kick );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_jump_kick] )
fight.c:	damage( ch, victim, number_range( 200, ch->level*4 ), gsn_jump_kick );
fight.c:	 || victim->in_room != ch->in_room )
fight.c:	chance = ch->pcdata->mod_str + ( ch->level - victim->level ) + ch->pcdata->perm_str;
fight.c:	 damage( ch, victim, number_range( 30, ch->level ), gsn_jump_kick );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_spin_kick] )
fight.c:	damage( ch, victim, number_range( 250, ch->level*5 ), gsn_spin_kick );
fight.c:	 || victim->in_room != ch->in_room )
fight.c:	chance = ch->pcdata->mod_str + ( ch->level - victim->level ) + ch->pcdata->perm_str;
fight.c:	 damage( ch, victim, number_range( 40, ch->level ), gsn_spin_kick  );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_punch] )
fight.c:	damage( ch, victim, number_range( 100, ch->level*3 ), gsn_punch );
fight.c:	 || victim->in_room != ch->in_room )
fight.c:	chance = ch->pcdata->mod_str + ( ch->level - victim->level ) + ch->pcdata->perm_str;
fight.c:	 damage( ch, victim, number_range( 1, ch->level ), gsn_punch );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_jab_punch] )
fight.c:	damage( ch, victim, number_range( 125, ch->level*3 ), gsn_jab_punch );
fight.c:	 || victim->in_room != ch->in_room )
fight.c:	chance = ch->pcdata->mod_str + ( ch->level - victim->level ) + ch->pcdata->perm_str;
fight.c:	 damage( ch, victim, number_range( 1, ch->level ), gsn_jab_punch );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_kidney_punch] )
fight.c:	damage( ch, victim, number_range( 150, ch->level*3 ), gsn_kidney_punch );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_cross_punch] )
fight.c:	damage( ch, victim, number_range( 175, ch->level*3 ), gsn_cross_punch );
fight.c:	 || victim->in_room != ch->in_room )
fight.c:	chance = ch->pcdata->mod_str + ( ch->level - victim->level ) + ch->pcdata->perm_str;
fight.c:	 damage( ch, victim, number_range( 1, ch->level ), gsn_cross_punch );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_roundhouse_punch] )
fight.c:	damage( ch, victim, number_range( 200, ch->level*3 ), gsn_roundhouse_punch );
fight.c:	 || victim->in_room != ch->in_room )
fight.c:	chance = ch->pcdata->mod_str + ( ch->level - victim->level ) + ch->pcdata->perm_str;
fight.c:	 damage( ch, victim, number_range( 1, ch->level ), gsn_roundhouse_punch );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_uppercut_punch] )
fight.c:	damage( ch, victim, number_range( 225, ch->level*3 ), gsn_uppercut_punch );
fight.c:	 || victim->in_room != ch->in_room )
fight.c:	chance = ch->pcdata->mod_str + ( ch->level - victim->level ) + ch->pcdata->perm_str;
fight.c:	 damage( ch, victim, number_range( 1, ch->level ), gsn_uppercut_punch );
fight.c:    if ( !ch->fighting )
fight.c:    if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_blindfight] > 0
fight.c:    && ch->pcdata->learned[gsn_blindfight] < number_percent( ) )
fight.c:    victim = ch->fighting;
fight.c:	 || victim->in_room != ch->in_room || count > 2 )
fight.c:	 || victim->in_room != ch->in_room || count > 2 )
fight.c:	 || victim->in_room != ch->in_room || count > 2 )
fight.c:	 || victim->in_room != ch->in_room || count > 2 )
fight.c:	 || victim->in_room != ch->in_room || count > 2 )
fight.c:	 || victim->in_room != ch->in_room || count > 2 )
fight.c:	 || victim->in_room != ch->in_room || count > 2 )
fight.c:	 || victim->in_room != ch->in_room || count > 2 )
fight.c:	 || victim->in_room != ch->in_room || count > 2 )
fight.c:	 || victim->in_room != ch->in_room || count > 2 )
fight.c:    if ( !ch->fighting )
fight.c:    if ( ch->level < L_APP && ch->class == CLASS_VAMPIRE )
fight.c:     if ( !IS_SET( ch->in_room->room_flags, ROOM_INDOORS ) )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_feed] )
fight.c:	  if ( ( ch->bp + amnt ) > MAX_BP(ch))
fight.c:	    ch->bp = MAX_BP(ch);
fight.c:	    ch->bp += amnt;
fight.c:	  damage( ch, victim, number_range( 1, ch->level ), gsn_feed );
fight.c:    if ( !ch->fighting )
fight.c:    victim = ch->fighting;
fight.c:    if ( victim->fighting != ch && ch->fighting != victim )
fight.c:    percent = number_percent( ) + victim->level - ch->level;
fight.c:	( percent < ch->pcdata->learned[gsn_disarm] * 2 / 3 ) ) )
fight.c:    if ( ( !IS_NPC( victim ) && victim->level >= ch->level && victim != ch ) ||
fight.c:        ( ch->pcdata && ch->pcdata->slayusee[0] != '\0' )
fight.c:        ? ch->pcdata->slayusee : "slay $N in cold blood." );
fight.c:    sprintf( buf, "%s %s.", ch->name,
fight.c:            ( ch->pcdata && ch->pcdata->slayvict[0] != '\0' )
fight.c:            ? ch->pcdata->slayvict : "slays you in cold blood!" );
fight.c:    sprintf( buf, "%s %s.", ch->name,
fight.c:            ( ch->pcdata && ch->pcdata->slayroom[0] != '\0' )
fight.c:            ? ch->pcdata->slayroom : "slays $N in cold blood!");
fight.c:    sprintf( log_buf, "%s slays %s at %d.\n\r", ch->name, victim->name,
fight.c:    log_string( log_buf, CHANNEL_LOG, ch->level - 1 );
fight.c:      return number_range( 5, ch->level + 5 );
fight.c:      return number_range( 3, ch->level + 3 );
fight.c:      return number_range( 2, ch->level + 2 );
fight.c:      return number_range( 1, ch->level );
fight.c:  return number_range( 1, ch->level );
fight.c:  in_room = ch->in_room;
fight.c:  to_room = ch->in_room;
fight.c:  if ( ( victim = ch->fighting ) == NULL )
fight.c:   in_room = ch->in_room;
fight.c:   to_room = ch->in_room;
fight.c:      if ( !( pexit[nsdir] = ch->in_room->exit[dir] ) 
fight.c:    if(!(victim = ch->fighting))
fight.c:  if(IS_NPC(ch) || number_percent() < ch->pcdata->learned[gsn_drain_life])
fight.c:    dam = ch->level + number_range(ch->level / 2, ch->level);
fight.c:    ch->hit = UMIN(ch->hit + dam/2, MAX_HIT(ch));
fight.c:    if(!(victim = ch->fighting))
fight.c:  if ( ch->race == RACE_ILLITHID )
fight.c:  if(IS_NPC(ch) || number_percent() < ch->pcdata->learned[gsn_mental_drain])
fight.c:    dam = number_range(ch->level / 5, ch->level);
fight.c:/*    drain = 2 * ch->level + number_range(ch->level / 4, ch->level * 2);*/
fight.c:    dmana = drain = ch->level + number_range(ch->level / 4, ch->level);
fight.c:     if ( ch->race == RACE_ILLITHID )
fight.c:/*    ch->hit = UMIN(ch->hit + dam/4, MAX_HIT(ch));*/
fight.c:    ch->mana = UMIN(ch->mana + dmana / 2, MAX_MANA(ch));
fight.c:    ch->move = UMIN(ch->move + drain / 2, MAX_MOVE(ch));
fight.c:  if ( !(victim = ch->fighting) )
fight.c:  if ( ( IS_NPC(ch) || number_percent() < ch->pcdata->learned[gsn_stun] ) &&
fight.c:      number_percent() < (ch->level * 75) / victim->level )
fight.c:  if ( !ch->fighting )
fight.c:  if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_berserk] < number_percent() )
fight.c:  af.level = ch->level;
fight.c:  af.duration = ch->level / 10;
fight.c:  af.modifier = IS_NPC(ch) ? ch->level / 2 : ch->damroll * 2 / 3;
fight.c:  af.modifier = IS_NPC(ch) ? ch->level / 2 : ch->hitroll * 2 / 3;
fight.c:  af.modifier = ch->level * -2;
fight.c:  CHAR_DATA *victim = ch->fighting;
fight.c:  if (!IS_NPC(ch) && ch->pcdata->learned[gsn_soulstrike] < number_percent( ))
fight.c:  dam = number_range( ch->level / 3, (ch->level * 2) / 3 );
fight.c:  if ( ch->hit < dam * 2 )
fight.c:  ch->hit -= dam;
fight.c:  CHAR_DATA *victim = ch->fighting;
fight.c:  if ( ch->pcdata->learned[gsn_multiburst] < number_percent( ) )
fight.c:  if ( !ch->fighting )
fight.c:  if ( ch->mana < mana && ch->level < LEVEL_IMMORTAL )
fight.c:					URANGE( 1, ch->level, LEVEL_HERO ),
fight.c:  if ( victim->position != POS_DEAD && ch->in_room == victim->in_room )
fight.c:					URANGE( 1, ch->level, LEVEL_HERO ),
fight.c:  if ( ch->level < LEVEL_IMMORTAL )
fight.c:  if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_rage] < number_percent( ) )
fight.c:		obj_to_room( wield, ch->in_room );
fight.c:		obj_to_room( wield2, ch->in_room );
fight.c:  af.level	 = ch->level;
fight.c:  af.duration	 = ch->level * 0.4;
fight.c:  af.modifier	 = ch->level;
fight.c:  af.modifier	 = ch->level;
fight.c:  int rvnum = ch->in_room->vnum;
fight.c:            arena.cch->name);
fight.c:  if ( award*100 > ( ch->money.gold*C_PER_G + ch->money.silver*S_PER_G +
fight.c:                     ch->money.copper ) )
fight.c:/*  if ( award > ( ch->money.gold + (ch->money.silver/SILVER_PER_GOLD) +
fight.c:               (ch->money.copper/COPPER_PER_GOLD) ) )  */
fight.c:  if ( award > ch->gold )
fight.c:  spend_money( &ch->money, &amount );
fight.c:  ch->gold -= award;
fight.c:	  ch->name, arena.och->name, award );
fight.c:          ch->name, award);
fight.c:  int rvnum = ch->in_room->vnum;
fight.c:  if ( ch->fighting )
fight.c:  if ( ( ch->money.gold*C_PER_G + ch->money.silver*S_PER_G +
fight.c:         ch->money.copper ) < arena.award*100 )
fight.c:/*  if ( (ch->money.gold + (ch->money.silver/SILVER_PER_GOLD) +
fight.c:       (ch->money.copper/COPPER_PER_GOLD) ) < arena.award )  */
fight.c:  spend_money( &ch->money, &amount );
fight.c:  if ( ch->gold < arena.award )
fight.c:  ch->gold -= arena.award;
fight.c:          ch->name, cch->name);
fight.c:    if(!(victim = ch->fighting))
fight.c:  if ( ch->level < 25 )
fight.c:  else if ( ch->level < 40 )
fight.c:  else if ( ch->level < 60 )
fight.c:  else if ( ch->level < 80 )
fight.c:  if(IS_NPC(ch) || number_percent() < ch->pcdata->learned[gsn_bite])
fight.c:    dam = ch->level + number_range(ch->level, ch->level * 5);
fight.c:  if ( ch->pcdata->learned[gsn_rush] < number_percent( ) )
fight.c:  af.level	 = ch->level;
fight.c:  af.duration	 = ch->level / 4;
fight.c:    if(!(victim = ch->fighting))
fight.c:  if(number_percent() < ch->pcdata->learned[gsn_howlfear])
fight.c:    af.level	 = ch->level;
fight.c:    af.modifier	 = 0 - ch->level / 2;
fight.c:    af.modifier	 = 0 - ch->level / 2;
fight.c:    af.level	 = ch->level;
fight.c:  if ( !ch->fighting )
fight.c:  if ( !IS_NPC(ch) && ch->pcdata->learned[gsn_frenzy] < number_percent() )
fight.c:  af.level = ch->level;
fight.c:  af.duration = ch->level / 10;
fight.c:  af.modifier = IS_NPC(ch) ? ch->level / 2 : ch->damroll * 2 / 3;
fight.c:  af.modifier = IS_NPC(ch) ? ch->level / 2 : ch->hitroll * 2 / 3;
fight.c:  af.modifier = ch->level * -2;
fight.c:  if ( ch->pcdata->learned[gsn_reflex] < number_percent( ) )
fight.c:  af.level	 = ch->level;
fight.c:  af.duration	 = ch->level / 4;
fight.c:    if ( !ch->fighting )
fight.c:    victim = ch->fighting;
fight.c:    if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_rake] )
fight.c:	damage( ch, victim, number_range( 100, ch->level*5 ), gsn_rake );
fight.c:	if ( !(victim = ch->fighting) )
fight.c:  if ( ch->pcdata->learned[gsn_bladepalm] > number_percent( ) )
fight.c:	int anatomy = ch->pcdata->learned[gsn_anatomyknow];
fight.c:	dam += number_fuzzy( ch->level / 2 + ch->level / 15 );
fight.c:	if ( ch->pcdata->learned[gsn_enhanced_damage] > 0 )
fight.c:		dam += dam / 4 * ch->pcdata->learned[gsn_enhanced_damage] / 150;
fight.c: if ( !ch->fighting )
fight.c: victim = ch->fighting;
fight.c: if ( IS_NPC( ch ) || number_percent( ) < ch->pcdata->learned[gsn_flykick] )
fight.c:	damage( ch, victim, number_range( 200, ch->level*6 ), gsn_flykick );
fight.c:  if ( !(victim = ch->fighting) )
fight.c:  if ( number_percent() < ch->pcdata->learned[gsn_nerve] 
fight.c:  && number_percent() < (ch->level * 75) / victim->level )
fight.c:  if ( !(victim=ch->fighting) )
fight.c:  if ( ch->pcdata->learned[gsn_trip] > number_percent( ) )
fight.c:  if ( !(victim = ch->fighting) )
fight.c:  if ( ( obj = victim->carrying ) && !saves_spell( ch->level, victim ) )
fight.c:  dam = number_range( 100, ch->level * 3 );
fight.c:    if ( ch->wait != 0 )
fight.c:    if ( number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( IS_SET( ch->act, PLR_COMBAT ) )
fight.c:    if ( IS_SET( ch->act, PLR_COMBAT ) )
gr_magic.c:    if (!ch->gspell || !victim->gspell)
gr_magic.c:    if (ch->gspell->sn != victim->gspell->sn)
gr_magic.c:    if (ch->gspell->victim != victim->gspell->victim)
gr_magic.c:    ch->gspell = gsp_new;
gr_magic.c:    if (!ch->gspell) {
gr_magic.c:    free_mem(ch->gspell, sizeof(*ch->gspell));
gr_magic.c:    ch->gspell = NULL;
gr_magic.c:    if (!ch->gspell || ch->gspell->timer <= 0)
gr_magic.c:    sn = ch->gspell->sn;
gr_magic.c:    for (gch = ch->in_room->people; gch; gch = gch->next_in_room) {
gr_magic.c:	    level = (level / 4) + gch->gspell->level;
gr_magic.c:    (*skill_table[sn].spell_fun) (sn, level, ch->leader ? ch->leader : ch,
gr_magic.c:				  ch->gspell->victim);
gr_magic.c:    for (gch = ch->in_room->people; gch; gch = gch->next_in_room) {
gr_magic.c:	    CHAR_DATA *victim = (CHAR_DATA *) ch->gspell->victim;
gr_magic.c:	    rprog_cast_sn_trigger(ch->in_room, ch, sn, victim);
gr_magic.c:		if (IS_NPC(victim) || (ch->leader ? ch->leader : ch) == victim)
gr_magic.c:		    multi_hit(victim, ch->leader ? ch->leader : ch, TYPE_UNDEFINED);
gr_magic.c:	rprog_cast_sn_trigger(ch->in_room, ch, sn, ch->gspell->victim);
gr_magic.c:	rprog_cast_sn_trigger(ch->in_room, ch, sn, ch);
gr_magic.c:	rprog_cast_sn_trigger(ch->in_room, ch, sn,
gr_magic.c:			 (ch->gspell->victim ? ch->gspell->victim : ch));
gr_magic.c:	if (ch->gspell->victim) {
gr_magic.c:	    oprog_cast_sn_trigger(ch->gspell->victim, ch, sn, ch->gspell->victim);
gr_magic.c:	    rprog_cast_sn_trigger(ch->in_room, ch, sn, ch->gspell->victim);
gr_magic.c:    for (gch = ch->in_room->people; gch; gch = gch->next_in_room) {
gr_magic.c:	if (gch == ch || !gch->gspell || gch->gspell->timer <= 0)
gr_magic.c:	if (is_same_group(ch, gch) && gch->gspell->sn == sn) {
gr_magic.c:		if (gch->gspell->victim != vo)
gr_magic.c:    if (!gch || !gch->gspell)
gr_magic.c:	gsp.timer = gch->gspell->timer;
gr_magic.c:    if (ch->gspell && ch->gspell->timer > 0) {
gr_magic.c:    if (number_percent() > ch->pcdata->learned[sn]) {
gr_magic.c:	    if (ch->fighting)
gr_magic.c:		victim = ch->fighting;
gr_magic.c:	if (!(obj = get_obj_list(ch, argument, ch->in_room->contents))) {
gr_magic.c:    for (vch = ch->in_room->people; vch; vch = vch->next_in_room) {
handler.c:    if (ch->desc && ch->desc->original)
handler.c:	ch = ch->desc->original;
handler.c:/*    if ( IS_CODER( ch ) && ch->trust < 100000 )
handler.c:    if (ch->trust != 0)
handler.c:	return ch->trust;
handler.c:    if (IS_NPC(ch) && ch->level >= LEVEL_HERO)
handler.c:	return ch->level;
handler.c:    return 17 + (ch->played + (int) (current_time - ch->logon)) / 14400;
handler.c:	max = 25 + (get_race_data(ch->race))->mstr;
handler.c:	max = 22 + (get_race_data(ch->race))->mstr;
handler.c:    return URANGE(3, ch->pcdata->perm_str + ch->pcdata->mod_str, max);
handler.c:	max = 25 + (get_race_data(ch->race))->mint;
handler.c:	max = 22 + (get_race_data(ch->race))->mint;
handler.c:    return URANGE(3, ch->pcdata->perm_int + ch->pcdata->mod_int, max);
handler.c:	max = 25 + (get_race_data(ch->race))->mwis;
handler.c:	max = 22 + (get_race_data(ch->race))->mwis;
handler.c:    return URANGE(3, ch->pcdata->perm_wis + ch->pcdata->mod_wis, max);
handler.c:	max = 25 + (get_race_data(ch->race))->mdex;
handler.c:	max = 22 + (get_race_data(ch->race))->mdex;
handler.c:    return URANGE(3, ch->pcdata->perm_dex + ch->pcdata->mod_dex, max);
handler.c:	max = 25 + (get_race_data(ch->race))->mcon;
handler.c:	max = 22 + (get_race_data(ch->race))->mcon;
handler.c:    return URANGE(3, ch->pcdata->perm_con + ch->pcdata->mod_con, max);
handler.c:    if (!IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL)
handler.c:    if (IS_NPC(ch) && IS_SET(ch->act, ACT_PET))
handler.c:    if (!IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL)
handler.c:    if (IS_NPC(ch) && IS_SET(ch->act, ACT_PET))
handler.c:		  (ch->money.gold / 1000 + ch->money.silver / 1000 + ch->money.copper / 1000));
handler.c:    if (ch && ch->desc && ch->desc->original)
handler.c:	ch = ch->desc->original;
handler.c:    else if (!IS_NPC(ch) && !IS_SET(ch->act, PLR_FULLNAME))
handler.c:	SET_BIT(ch->affected_by, paf->bitvector);
handler.c:	REMOVE_BIT(ch->affected_by, paf->bitvector);
handler.c:		paf->location, ch->name);
handler.c:	    ch->pcdata->mod_str += mod;
handler.c:	    ch->pcdata->mod_dex += mod;
handler.c:	    ch->pcdata->mod_int += mod;
handler.c:	    ch->pcdata->mod_wis += mod;
handler.c:	    ch->pcdata->mod_con += mod;
handler.c:	ch->sex += mod;
handler.c:	ch->mod_mana += mod;
handler.c:	ch->mod_bp += mod;
handler.c:	ch->antidisarm += mod;
handler.c:	ch->mod_hit += mod;
handler.c:	ch->mod_move += mod;
handler.c:	ch->armor += mod;
handler.c:	ch->hitroll += mod;
handler.c:	ch->damroll += mod;
handler.c:	ch->saving_throw += mod;
handler.c:	ch->saving_throw += mod;
handler.c:	ch->saving_throw += mod;
handler.c:	ch->saving_throw += mod;
handler.c:	ch->saving_throw += mod;
handler.c:	paf->level = ch->level;
handler.c:	    af.level = ch->level;
handler.c:	    af.level = ch->level;
handler.c:		REMOVE_BIT(ch->affected_by, AFF_HIDE);
handler.c:	    SET_BIT(ch->affected_by, AFF_HIDE);
handler.c:	    REMOVE_BIT(ch->affected_by, AFF_HIDE);
handler.c:	    obj_to_room(wield, ch->in_room);
handler.c:	SET_BIT(ch->affected_by2, paf->bitvector);
handler.c:	REMOVE_BIT(ch->affected_by2, paf->bitvector);
handler.c:		paf->location, ch->name);
handler.c:	    ch->pcdata->mod_str += mod;
handler.c:	    ch->pcdata->mod_dex += mod;
handler.c:	    ch->pcdata->mod_int += mod;
handler.c:	    ch->pcdata->mod_wis += mod;
handler.c:	    ch->pcdata->mod_con += mod;
handler.c:	ch->sex += mod;
handler.c:	ch->mod_mana += mod;
handler.c:	ch->mod_bp += mod;
handler.c:	ch->antidisarm += mod;
handler.c:	ch->mod_hit += mod;
handler.c:	ch->mod_move += mod;
handler.c:	ch->armor += mod;
handler.c:	ch->hitroll += mod;
handler.c:	ch->damroll += mod;
handler.c:	ch->saving_throw += mod;
handler.c:	ch->saving_throw += mod;
handler.c:	ch->saving_throw += mod;
handler.c:	ch->saving_throw += mod;
handler.c:	ch->saving_throw += mod;
handler.c:	    obj_to_room(wield, ch->in_room);
handler.c:    paf_new->next = ch->affected;
handler.c:    ch->affected = paf_new;
handler.c:    paf_new->next = ch->affected2;
handler.c:    ch->affected2 = paf_new;
handler.c:    if (!ch->affected) {
handler.c:    if (!ch->affected2) {
handler.c:    for (paf = ch->affected; paf; paf = paf->next) {
handler.c:    for (paf = ch->affected2; paf; paf = paf->next) {
handler.c:    for (paf = ch->affected; paf; paf = paf->next) {
handler.c:    for (paf = ch->affected2; paf; paf = paf->next) {
handler.c:    for (paf_old = ch->affected; paf_old; paf_old = paf_old->next) {
handler.c:    for (paf_old = ch->affected2; paf_old; paf_old = paf_old->next) {
handler.c:    if (!ch->in_room) {
handler.c:    if (!IS_NPC(ch) && ch->in_room->area)
handler.c:	--ch->in_room->area->nplayer;
handler.c:	&& ch->in_room->light > 0)
handler.c:	--ch->in_room->light;
handler.c:    if (ch == ch->in_room->people) {
handler.c:	ch->in_room->people = ch->next_in_room;
handler.c:	for (prev = ch->in_room->people; prev; prev = prev->next_in_room) {
handler.c:		prev->next_in_room = ch->next_in_room;
handler.c:    ch->in_room = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:    ch->in_room = pRoomIndex;
handler.c:    ch->next_in_room = pRoomIndex->people;
handler.c:    if (!IS_NPC(ch) && ch->in_room->area)
handler.c:	++ch->in_room->area->nplayer;
handler.c:	++ch->in_room->light;
handler.c:    obj->next_content = ch->carrying;
handler.c:    ch->carrying = obj;
handler.c:    ch->carry_number += get_obj_number(obj);
handler.c:    ch->carry_weight += get_obj_weight(obj);
handler.c:	bug("obj_to_storage: NPC storage from %d", ch->pIndexData->vnum);
handler.c:    obj->next_content = ch->pcdata->storage;
handler.c:    ch->pcdata->storage = obj;
handler.c:    ch->pcdata->storcount++;
handler.c:    if (ch->carrying == obj) {
handler.c:	ch->carrying = obj->next_content;
handler.c:	for (prev = ch->carrying; prev; prev = prev->next_content) {
handler.c:    ch->carry_number -= get_obj_number(obj);
handler.c:    ch->carry_weight -= get_obj_weight(obj);
handler.c:	bug("obj_from_storage: NPC storage by %d.", ch->pIndexData->vnum);
handler.c:    if (ch->pcdata->storage == obj) {
handler.c:	ch->pcdata->storage = obj->next_content;
handler.c:	for (prev = ch->pcdata->storage; prev; prev = prev->next_content) {
handler.c:    ch->pcdata->storcount--;
handler.c:    for (obj = ch->carrying; obj; obj = obj->next_content) {
handler.c:		ch->name, iWear);
handler.c:	obj_to_room(obj, ch->in_room);
handler.c:    ch->armor -= apply_ac(obj, iWear);
handler.c:	&& ch->in_room)
handler.c:	++ch->in_room->light;
handler.c:    ch->carry_number -= get_obj_number(obj);
handler.c:		ch->name, obj->pIndexData->vnum);
handler.c:    ch->armor += apply_ac(obj, obj->wear_loc);
handler.c:	&& ch->in_room
handler.c:	&& ch->in_room->light > 0)
handler.c:	--ch->in_room->light;
handler.c:    ch->carry_number += get_obj_number(obj);
handler.c:    if (!ch->in_room) {
handler.c:	    name = ch->short_descr;
handler.c:	    name = ch->name;
handler.c:	for (obj = ch->carrying; obj; obj = obj_next) {
handler.c:	      ch->level <= 20 ? ", your battered corpse next to you.\n\r"
handler.c:	--ch->pIndexData->count;
handler.c:    if (ch->desc && ch->desc->original)
handler.c:    for (wch = char_list; wch; wch = wch->next) {
handler.c:	if (wch->reply == ch)
handler.c:	    wch->reply = NULL;
handler.c:	if (wch->hunting == ch)
handler.c:	    wch->hunting = NULL;
handler.c:    ch->deleted = TRUE;
handler.c:    if (ch->desc)
handler.c:	ch->desc->character = NULL;
handler.c:    for (rch = ch->in_room->people; rch; rch = rch->next_in_room) {
handler.c:	if (!can_see(ch, rch) || !is_name(ch, arg, rch->name))
handler.c:    for (wch = char_list; wch; wch = wch->next) {
handler.c:	if (!can_see(ch, wch) || !is_name(ch, arg, wch->name))
handler.c:    for (obj = ch->carrying; obj; obj = obj->next_content) {
handler.c:	bug("get_obj_storage: NPC storage from %d", ch->pIndexData->vnum);
handler.c:    for (obj = ch->pcdata->storage; obj; obj = obj->next_content) {
handler.c:    for (obj = ch->carrying; obj; obj = obj->next_content) {
handler.c:    obj = get_obj_list(ch, argument, ch->in_room->contents);
handler.c:    for (rch = pRoomIndex->people; rch; rch = rch->next_in_room) {
handler.c:	if (rch->deleted)
handler.c:	&& (ch->in_room->vnum != victim->in_room->vnum)
handler.c:    if (!IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT))
handler.c:    if (is_raffected(ch->in_room, gsn_globedark)
handler.c:	&& ch->race != RACE_DROW)
handler.c:	&& ch->race != RACE_ILLITHID)
handler.c:    if (room_is_dark(ch->in_room)
handler.c:	&& (ch->race != RACE_ELF)
handler.c:	&& (ch->race != RACE_DWARF)
handler.c:	&& (ch->race != RACE_DROW)
handler.c:	&& (ch->race != RACE_DEMON))
handler.c:		&& ch->level < 50)))
handler.c:	&& (ch->race != RACE_DEMON)
handler.c:	    && ch->level < 30))
handler.c:	&& ch->race != RACE_DWARF
handler.c:	&& ch->race != RACE_DEMON)
handler.c:    if (!IS_NPC(ch) && IS_SET(ch->act, PLR_HOLYLIGHT))
handler.c:	&& ch->race != RACE_ILLITHID)
handler.c:    if (is_raffected(ch->in_room, gsn_globedark)
handler.c:	&& ch->race != RACE_DROW)
handler.c:    if (room_is_dark(ch->in_room)
handler.c:	&& (ch->race != RACE_ELF)
handler.c:	&& (ch->race != RACE_DWARF)
handler.c:	&& (ch->race != RACE_DROW)
handler.c:	&& (ch->race != RACE_DEMON))
handler.c:	&& (ch->race != RACE_DEMON))
handler.c:    if (!IS_NPC(ch) && ch->level >= LEVEL_IMMORTAL &&
handler.c:    if (!ch->pcdata)
handler.c:	return ch->desc->original;
handler.c:	if (IS_SET(ch->imm_flags, IMM_WEAPON))
handler.c:	else if (IS_SET(ch->res_flags, RES_WEAPON))
handler.c:	else if (IS_SET(ch->vul_flags, VULN_WEAPON))
handler.c:	if (IS_SET(ch->imm_flags, IMM_MAGIC))
handler.c:	else if (IS_SET(ch->res_flags, RES_MAGIC))
handler.c:	else if (IS_SET(ch->vul_flags, VULN_MAGIC))
handler.c:    if (IS_SET(ch->imm_flags, bit))
handler.c:    else if (IS_SET(ch->res_flags, bit) && immune != IS_IMMUNE)
handler.c:    else if (IS_SET(ch->vul_flags, bit)) {
handler.c:    int level = ch->level + 1;
handler.c:    if (IS_NPC(ch) || ch->level >= L_CHAMP3)
handler.c:	return ch->exp;
handler.c:    if (ch->level < LEVEL_HERO)
handler.c:    else if (ch->level < L_CHAMP3) {
handler.c:    return is_name(ch, ch->name, room->owner);
houses.c:    loc = ch->in_room;
houses.c:    loc_area = ch->in_room->area;
houses.c:    if (!is_name(ch, ch->in_room->area->filename, "hog.are")) {
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 5000) {
houses.c:	    ch->money.gold -= 5000;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 1000) {
houses.c:	    ch->money.gold -= 1000;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 2000) {
houses.c:	    ch->money.gold -= 2000;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 1500) {
houses.c:	    ch->money.gold -= 1500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 1000) {
houses.c:	    ch->money.gold -= 1000;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 1000) {
houses.c:	    ch->money.gold -= 1000;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 2500) {
houses.c:	    ch->money.gold -= 2500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 5000) {
houses.c:	    ch->money.gold -= 5000;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 7500) {
houses.c:	    ch->money.gold -= 7500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 8500) {
houses.c:	    ch->money.gold -= 8500;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:	    if (ch->money.gold < 9900) {
houses.c:	    ch->money.gold -= 9900;
houses.c:	    obj_to_room(furn, ch->in_room);
houses.c:    loc = ch->in_room;
houses.c:    loc_area = ch->in_room->area;
houses.c:	if (ch->money.gold < 25000) {
houses.c:	    loc->owner = str_dup(ch->name);
houses.c:	    ch->money.gold -= 25000;
houses.c:	    sprintf(buf, "%s's Home", ch->name);
houses.c:    loc = ch->in_room;
houses.c:    loc_area = ch->in_room->area;
houses.c:	ch->money.gold += 12500;
houses.c:	if (!ch->in_room->reset_first) {
houses.c:	for (current_reset = ch->in_room->reset_first; current_reset;
houses.c:	ch->in_room->reset_first = NULL;
houses.c:	for (furn = ch->in_room->contents; furn != NULL; furn = furn_next) {
houses.c:    loc = ch->in_room;
houses.c:    loc_area = ch->in_room->area;
hunt_info.c:	strcpy(buf,(get_race_data(ch->race))->race_name);
hunt_info.c:	if (wch->level >= LEVEL_HERO)
hunt_info.c:	    switch (wch->level) 
hunt_info.c:		class = wch->sex == 2 ? "{MSTORM LADY{x"
hunt_info.c:		class = wch->sex == 2 ? "GODDESS"
hunt_info.c:		    class = wch->sex == 2 ? "{CMATRIARCH{x"
hunt_info.c:		    class = wch->sex == 2 ? "{gLADYRANGER{x"
hunt_info.c:	if (wch->level >= L_APP
hunt_info.c:	    && wch->pcdata->whotype
hunt_info.c:	    && str_cmp(wch->pcdata->whotype, "!!!!!!!!!!!!")
hunt_info.c:	    && str_cmp(wch->pcdata->whotype, "(null)"))
hunt_info.c:	    class = wch->pcdata->whotype;
hunt_info.c:	if (IS_SET(wch->act, PLR_QUEST)) 
hunt_info.c:	if (IS_SET(wch->act, PLR_QUESTOR))
hunt_info.c:	if (wch->desc && wch->desc->editor != 0) 
hunt_info.c:	    if (wch->desc->editor == 13)	/* forging eq */
hunt_info.c:	if (IS_SET(wch->act, PLR_PKILLER)) strcat(status,"<K> ");
hunt_info.c:        if (IS_SET(wch->act, PLR_AFK)) strcat(status,"<A> ");
hunt_info.c:	if (IS_SET(wch->act, PLR_WIZINVIS)) strcat(status,"<W> ");
hunt_info.c:	if (IS_SET(wch->act, PLR_CLOAKED)) strcat(status,"<C> ");
hunt_info.c:	sprintf(buf,"%d",ch->level);
hunt_info.c:	if (wch->pcdata->lname)
hunt_info.c:		    wch->name, (wch->pcdata->lname[0] != '\0') ? " " : "",
hunt_info.c:		    wch->pcdata->lname, wch->pcdata->title);
hunt_info.c:	   sprintf(buf, "%s%s\n\r", wch->name, wch->pcdata->title);
hunt_info.c:		if (wch->level >= L_APP) tot_imm++;
hunt_info.c:		if (wch->level < 10) tot_newb++;
interp.c:    if (ch->wait > 0)
interp.c:    if (!IS_NPC(ch) && IS_SET(ch->act, PLR_FREEZE)) {
interp.c:	sprintf(log_buf, "%s: %s", ch->name, logline);
interp.c:    if ((!IS_NPC(ch) && IS_SET(ch->act, PLR_LOG))
interp.c:	sprintf(log_buf, "%s: %s", ch->name, logline);
interp.c:	log_string(log_buf, (ch->level == L_IMP ? CHANNEL_NONE : CHANNEL_GOD),
interp.c:		   ((ch->level > 100) ? get_trust(ch) : -1));
interp.c:    if (ch->desc && ch->desc->snoop_by) {
interp.c:	sprintf(log_buf, "%s%%", ch->name);
interp.c:	write_to_buffer(ch->desc->snoop_by, log_buf, 0);
interp.c:	write_to_buffer(ch->desc->snoop_by, logline, 0);
interp.c:	write_to_buffer(ch->desc->snoop_by, "\n\r", 2);
interp.c:		    REMOVE_BIT(ch->affected_by, AFF_HIDE);
interp.c:		REMOVE_BIT(ch->affected_by, AFF_HIDE);
interp.c:    if (ch->position < cmd_table[cmd].position) {
interp.c:	switch (ch->position) {
interp.c:   sprintf(combuf, "%s: [%d] %s %s\n\r", ctime( &current_time), ch->pIndexData->vnum, command, argument);
interp.c:    if (IS_SET(ch->act, PLR_AFK)) {	/* if player was afk, remove afk */
interp.c:	REMOVE_BIT(ch->act, PLR_AFK);
interp.c:	sprintf(buf, "Memcheck : Increase in strings :: %s : %s", ch->name, cmd_copy);
interp.c:	sprintf(buf, "Increase in perms :: %s : %s", ch->name, cmd_copy);
interp.c:	if (is_name(NULL, cmd_table[cmd].name, ch->pcdata->empowerments))
interp.c:	if (is_name(NULL, cmd_table[cmd].name, ch->pcdata->detractments))
interp.c:    if (!(ch->pcdata->alias_list))
interp.c:    for (al = ch->pcdata->alias_list; al; al = al->next) {
interp.c:    if (!IS_NPC(ch) && IS_SET(ch->act, PLR_NO_EMOTE)) {
interp.c:    switch (ch->position) {
interp.c:	    if ((ch->in_room->vnum == ROOM_VNUM_HELL) &&
interp.c:		(ch->level < LEVEL_IMMORTAL)) {
interp.c:		if ((victim->level < ch->level)
interp.c:    if (!ch->pcdata->alias_list) {
interp.c:    for (pA1 = ch->pcdata->alias_list; pA1; pA1 = pA1_next) {
interp.c:    ch->pcdata->alias_list = NULL;
interp.c:	if (!ch->pcdata->alias_list) {
interp.c:	for (al = ch->pcdata->alias_list; al; al = al->next) {
interp.c:    if (arg1[0] == '\0' && (!(ch->pcdata->alias_list))) {
interp.c:	for (oAl = ch->pcdata->alias_list; oAl; oAl = oAl->next) {
interp.c:    for (al = ch->pcdata->alias_list; al; al = al->next)
interp.c:	if (al == ch->pcdata->alias_list)
interp.c:	    ch->pcdata->alias_list = al->next;
interp.c:	    for (oAl = ch->pcdata->alias_list; oAl; oAl = oAl->next)
interp.c:		sprintf(log_buf, "Do_alias: bad alias - ch (%s) - [%s]", ch->name, arg);
interp.c:       al->next = ch->pcdata->alias_list;
interp.c:       ch->pcdata->alias_list = al;
interp.c:    pAl->next = ch->pcdata->alias_list;
interp.c:    ch->pcdata->alias_list = pAl;
interp.c:    SET_BIT(ch->act, PLR_AFK);
interp.c:	if (ch->level < 20) {
interp.c:	if (IS_SET(ch->act, PLR_PKILLER)) {
interp.c:	SET_BIT(ch->act, PLR_PKILLER);
interp.c:    if (arena.fch->in_room == arena.sch->in_room)
magic.c:    char_to_room( zombie, ch->in_room );
magic.c:    char_to_room( victim, ch->in_room );
magic.c:  if ( ch->pcdata->learned[sn] <= 0 
magic.c:    || ch->pcdata->learned[sn] >= adept )
magic.c:  ch->pcdata->learned[sn] += ( get_curr_wis( ch ) / 5 );
magic.c:  if ( ch->pcdata->learned[sn] > adept )
magic.c:    ch->pcdata->learned[sn] = adept;
magic.c:   xp = ch->level / 5;
magic.c:   if (!(ch->fighting))
magic.c:    for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
magic.c:      if ( IS_SET( ch->affected_by, AFF_CHARM ) )
magic.c:    if ( ( sn == spec )  && ( is_name( ch, arg2, ch->name ) ) )
magic.c:	group_cast( sn, URANGE( 1, ch->level, LEVEL_HERO ), ch, arg2 );
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_OFFENSIVE ) )
magic.c:	    if ( !( victim = ch->fighting ) )
magic.c:	    REMOVE_BIT( ch->affected_by, AFF_PEACE );
magic.c:	if ( arg2[0] != '\0' && !is_name( ch, arg2, ch->name ) )
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:    (*skill_table[sn].spell_fun) ( sn, URANGE( 1, ch->level, LEVEL_HERO ),
magic.c:      rprog_cast_sn_trigger( ch->in_room, ch, sn, vo );
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
magic.c:	    if ( vch->deleted )
magic.c:     if ( !str_prefix( arg1, "divine" ) && ch->level >= LEVEL_IMMORTAL )
magic.c:      if ( IS_SET( ch->affected_by, AFF_CHARM ) )
magic.c:    if ( ch->position < skill_table[sn].minimum_position )
magic.c:    if ( ch->level < LEVEL_IMMORTAL && ch->class == CLASS_VAMPIRE )
magic.c:     if ( !IS_SET( ch->in_room->room_flags, ROOM_INDOORS ) )
magic.c:    if ( !IS_NPC( ch ) && ( !( ch->level > LEVEL_MORTAL ) ) )
magic.c:    if ( ch->race == RACE_ELF || ch->race == RACE_ELDER )
magic.c:	group_cast( sn, URANGE( 1, ch->level, LEVEL_HERO ), ch, arg2 );
magic.c:	if ( IS_SET( ch->in_room->room_flags, ROOM_NO_OFFENSIVE ) )
magic.c:	    if ( !( victim = ch->fighting ) )
magic.c:	    REMOVE_BIT( ch->affected_by, AFF_PEACE );
magic.c:	if ( arg2[0] != '\0' && !is_name( ch, arg2, ch->name ) )
magic.c:    if ( !is_class( ch, CLASS_VAMPIRE ) && ch->mana < mana )
magic.c:       if ( ( ch->bp < mana ) && ( is_class( ch, CLASS_VAMPIRE ) ) )
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:    if ( ( IS_SET( ch->in_room->room_flags, ROOM_NO_OFFENSIVE ) ) && ( skill_table[sn].target == TAR_CHAR_OFFENSIVE ) )
magic.c:    if ( number_percent( ) > ch->pcdata->learned[sn] )
magic.c:				      URANGE( 1, ch->level, LEVEL_HERO )*3 :
magic.c:				      URANGE( 1, ch->level, LEVEL_HERO ) ,
magic.c:				      URANGE( 1, ch->level, LEVEL_HERO )*3 :
magic.c:				      URANGE( 1, ch->level, LEVEL_HERO ) ,
magic.c:      rprog_cast_sn_trigger( ch->in_room, ch, sn, vo );
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
magic.c:	    if ( vch->deleted )
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_MAGIC ) )
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_OFFENSIVE ) )
magic.c:	    victim = ch->fighting;
magic.c:	if ( ( ( ch->clan == 0 ) || ( ch->clan == 0 ) ) && ( !IS_NPC( victim ) ) )
magic.c:	    REMOVE_BIT( ch->affected_by, AFF_PEACE );
magic.c:    if ( ( ( ch->level - 9 > victim->level ) 
magic.c:      || ( ch->level + 9 < victim->level ) )
magic.c:      rprog_cast_sn_trigger( ch->in_room, ch, sn, vo );
magic.c:	for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
magic.c:	    if ( vch->deleted )
magic.c:	|| IS_SET( ch->in_room->room_flags, ROOM_NO_ASTRAL_OUT ) 
magic.c:    for ( pet = ch->in_room->people; pet; pet = pet->next_in_room )
magic.c:    if (    ch->in_room->sector_type == SECT_INSIDE 
magic.c:         || ch->in_room->sector_type == SECT_CITY 
magic.c:         || ch->in_room->sector_type == SECT_AIR 
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_NO_SHADOW ) )
magic.c:        || victim->in_room->area != ch->in_room->area
magic.c:    for ( pet = ch->in_room->people; pet; pet = pet->next_in_room )
magic.c:    if ( blood_count( ch->in_room->contents, 5 ) < 2 )
magic.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
magic.c:    for ( vch = char_list; vch; vch = vch->next )
magic.c:	if ( vch->deleted || !vch->in_room )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	if ( vch->in_room->area == ch->in_room->area
magic.c:    obj_to_room( light, ch->in_room );
magic.c:    obj_to_room( mushroom, ch->in_room );
magic.c:    obj_to_room( spring, ch->in_room );
magic.c:    for ( vch = char_list; vch; vch = vch->next )
magic.c:        if ( vch->deleted || !vch->in_room )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	if ( vch->in_room->area == ch->in_room->area )
magic.c:    for ( vch = char_list; vch; vch = vch->next )
magic.c:	if ( vch->deleted || !vch->in_room )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	if ( vch->in_room->area == ch->in_room->area )
magic.c:	for (tmp_vict = ch->in_room->people; 
magic.c:    for ( vch = char_list; vch; vch = vch->next )
magic.c:        if ( vch->deleted || !vch->in_room )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:    /* ch->alignment = UMAX(-1000, ch->alignment - 200); */
magic.c:	dam		 = ch->hit + 1;
magic.c:	if ( ( ch->hit + dam ) > ( MAX_HIT(ch) + 200 ) ) 
magic.c:	    ch->hit = ( MAX_HIT(ch) + 200 );
magic.c:	  ch->hit		+= dam;
magic.c:    for ( vch = char_list; vch; vch = vch->next )
magic.c:        if ( vch->deleted || !vch->in_room )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	if ( vch->in_room->area == ch->in_room->area )
magic.c:	|| IS_SET( ch->in_room->room_flags, ROOM_NO_ASTRAL_OUT ) )
magic.c:    blah = ch->in_room;
magic.c:    for ( ich = ch->in_room->people; ich; ich = ich->next_in_room )
magic.c:	if ( !IS_NPC( ich ) && IS_SET( ich->act, PLR_WIZINVIS ) )
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_HIDE	);
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_INVISIBLE	);
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_SNEAK	);
magic.c:	REMOVE_BIT   ( ich->affected_by2, AFF_PHASED    );
magic.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
magic.c:		 ch->in_room );
magic.c:    berry->timer = ch->level;
magic.c:    berry->value[0] = ch->level * 3;
magic.c:    berry->value[1] = ch->level * 8;
magic.c:    victim->hit = UMIN( (victim->hit + (ch->level*5)), MAX_HIT(victim) );
magic.c:    af.duration  = ch->level/6;
magic.c:    af.duration  = ch->level/6;   
magic.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
magic.c:       free_string( ch->long_descr );
magic.c:       ch->long_descr = str_dup(buf);
magic.c:       free_string( ch->long_descr );
magic.c:       ch->long_descr = str_dup(buf);
magic.c:	|| IS_SET( ch->in_room->room_flags, ROOM_NO_ASTRAL_OUT )
magic.c:    gate2->value[0] = ch->in_room->vnum;
magic.c:    obj_to_room( gate1, ch->in_room );
magic.c:    sprintf( buf, "%s lifts his hands and webs entanle you!\n\r", ch->name );
magic.c:      sprintf(buf1, "%s attempted to probe your mind.", ch->name );
magic.c:        sprintf( buf, "Bamfusee: %s.\n\r", ch->pcdata->bamfusee );
magic.c:        sprintf( buf, "Transto: %s.\n\r", ch->pcdata->transto );
magic.c:        sprintf( buf, "Transfrom: %s.\n\r", ch->pcdata->transfrom );
magic.c:        sprintf( buf, "Transvict: %s.\n\r", ch->pcdata->transvict );
magic.c:        sprintf( buf, "Slayusee: %s.\n\r", ch->pcdata->slayusee );
magic.c:        sprintf( buf, "Slayroom: %s.\n\r", ch->pcdata->slayroom );
magic.c:        sprintf( buf, "Slayvict: %s.\n\r", ch->pcdata->slayvict );
magic.c:    if ( ch->level >= 20 )
magic.c:    if ( ch->level >= 12 )
magic.c:    if ( ch->level >= 8 )
magic.c:	    if ( ch->level >= 20 )
magic.c:	    if ( ch->level >= 20 )
magic.c:    sprintf( buf, "%s calls forth nature to hold you in place.\n\r", ch->name );
magic.c:	|| ch->in_room->area == arena.area
magic.c:    char_to_room( victim, ch->in_room );
magic.c:    ch->position = POS_STUNNED;
magic.c:    for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
magic.c:	if ( !is_name( NULL, speaker, vch->name ) )
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:        vch_next = vch->next_in_room;
magic.c:        if ( vch->deleted )
magic.c:	    hpch = UMAX( 10, ch->hit );
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
magic.c:	if ( !is_name( NULL, speaker, vch->name ) )
magic.c:    for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
magic.c:/*      vch_next = vch->next_in_room;*/
magic.c:	if ( vch->deleted )
magic.c:	    hpch = URANGE( 10, ch->hit, 999 );
magic.c:		&& (   level <= vch->level + 5
magic.c:		    && level >= vch->level - 5 ) )
magic.c:		vch->hit = 1;
magic.c:    if ( ch->race == RACE_ILLITHID )
magic.c:	ch->wait /= 2;
magic.c:	vch->mana = URANGE( 0, vch->mana, MAX_MANA(vch));
magic.c:	vch->bp = URANGE( 0, vch->bp, MAX_BP(vch));
magic.c:    if ( number_percent() < ch->pcdata->learned[sn]/2
magic.c:	+ 3 * ( ch->level - obj->level ) )
magic.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
magic.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
magic.c:    if ( ch->hit-hpch < 50 )
magic.c:    ch->hit     -= hpch;
magic.c:    if ( saves_spell( level, victim ) && ch->race != RACE_ILLITHID )
magic.c:    for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:        vch_next = vch->next_in_room;
magic.c:	if ( vch->deleted )
magic.c:	    hpch = UMAX( 10, ch->hit );
magic.c:  if(ch->summon_timer > 0)
magic.c:  ch->summon_timer = 10;
magic.c:  char_to_room(mob, ch->in_room);
magic.c:  if(ch->position == POS_FIGHTING)
magic.c:    fch = ch->fighting;
magic.c:    fch->fighting = mob;
magic.c:  if(ch->summon_timer > 0)
magic.c:  ch->summon_timer = 15;
magic.c:  char_to_room(mob, ch->in_room);
magic.c:  if(ch->position == POS_FIGHTING)
magic.c:    fch = ch->fighting;
magic.c:  if(ch->summon_timer > 0)
magic.c:  ch->summon_timer = 16;
magic.c:  char_to_room(mob, ch->in_room);
magic.c:  if(ch->position == POS_FIGHTING)
magic.c:    fch = ch->fighting;
magic.c:  if(ch->summon_timer > 0)
magic.c:  ch->summon_timer = 16;
magic.c:  char_to_room(mob, ch->in_room);
magic.c:  if(ch->position == POS_FIGHTING)
magic.c:    fch = ch->fighting;
magic.c:  if(ch->summon_timer > 0)
magic.c:  ch->summon_timer = 16;
magic.c:  char_to_room(mob, ch->in_room);
magic.c:  if(ch->position == POS_FIGHTING)
magic.c:    fch = ch->fighting;
magic.c:  if(ch->summon_timer > 0)
magic.c:  ch->summon_timer = 16;
magic.c:  char_to_room(mob, ch->in_room);
magic.c:  if(ch->position == POS_FIGHTING)
magic.c:    fch = ch->fighting;
magic.c:  if(ch->summon_timer > 0)
magic.c:  sprintf(buf, mob->long_descr, beast, ch->name);
magic.c:  ch->summon_timer = 16;
magic.c:  char_to_room(mob, ch->in_room);
magic.c:  if(ch->position == POS_FIGHTING)
magic.c:    fch = ch->fighting;
magic.c:   && !(IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim))
magic.c:   && !(IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim))
magic.c:    for ( rch = ch->in_room->people; rch; rch = rch->next_in_room )
magic.c:	if ( rch->fighting )
magic.c:  for ( obj = ch->in_room->contents; obj; obj = obj->next )
magic.c:    ch->mana += mana;
magic.c:    ch->mana = UMIN( MAX_MANA(ch), ch->mana );
magic.c:   soulgem->level = ch->level;
magic.c:   soulgem->timer = ch->level / 4;
magic.c:  af.level	 = ch->level;
magic.c:  af.duration	 = ch->level / 6;
magic.c:  af.modifier	 = 0 - number_fuzzy( ch->level ) / 2;
magic.c:  af.level	 = ch->level * 2;
magic.c:  af.duration	 = ch->level / 4;
magic.c:  af.modifier	 = 0 - ch->level/4;
magic.c:  af.modifier	 = 0 - ch->level / 4;
magic.c:  if ( ch->level < 50 )
magic.c:  else if ( ch->level < 60 )
magic.c:  else if ( ch->level < 70 )
magic.c:  else if ( ch->level < 80 )
magic.c:  else if ( ch->level < 90 )
magic.c:  else if ( ch->level < 95 )
magic.c:  if ( !IS_NPC( ch ) && ch->pcdata->learned[gsn_spellcraft] > 0 )
magic.c:	dam += dam * ch->pcdata->learned[gsn_spellcraft] / mod;
magic.c:    for( victim = ch->in_room->people; victim; victim = victim->next_in_room )
magic.c:	  sprintf( buf, "You become inspired by %s's song.\n\r", ch->name );
magic.c:    for( victim = ch->in_room->people; victim; victim = victim->next_in_room )
magic.c:    for ( victim = ch->in_room->people; victim; victim = victim->next_in_room )
magic.c:    if (    IS_SET( ch->in_room->room_flags, ROOM_SAFE     )
magic.c:	 || IS_SET( ch->in_room->room_flags, ROOM_NO_OFFENSIVE ) )
magic.c:    for ( vch = ch->in_room->people; vch; vch = vch->next_in_room )
magic.c:	if ( vch->deleted )
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	/*bug( "Mpasound - No argument: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    was_in_room = ch->in_room;
mob_commands.c:	    ch->in_room = pexit->to_room;
mob_commands.c:    ch->in_room = was_in_room;
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    if (IS_AFFECTED(ch, AFF_CHARM) && ch->master == victim) {
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    if (ch->position == POS_FIGHTING) {
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	/*bug( "Mpjunk - No argument: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	for (obj = ch->carrying; obj != NULL; obj = obj_next) {
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	/*bug( "Mpechoaround - No argument:  vnum %d.", ch->pIndexData->vnum); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	/*bug( "Mpmload - Bad vnum as arg: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	/*bug( "Mpmload - Bad mob vnum: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    char_to_room(victim, ch->in_room);
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	/*bug( "Mpoload - Bad vnum arg: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	    /*bug( "Mpoload - Bad syntax: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		    ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	    /*bug( "Mpoload - Bad level: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		    ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	obj_to_room(obj, ch->in_room);
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	for (victim = ch->in_room->people; victim != NULL; victim = vnext) {
mob_commands.c:	for (obj = ch->in_room->contents; obj != NULL; obj = obj_next) {
mob_commands.c:	    /*bug( "Mppurge - Bad argument: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		    ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	/*bug( "Mppurge - Purging a PC: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	/*bug( "Mpgoto - No argument: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	/*bug( "Mpgoto - No such location: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    if (location == ch->in_room)
mob_commands.c:    if (ch->fighting != NULL)
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	/*bug( "Mpat - Bad argument: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	/*bug( "Mpat - No such location: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    original = ch->in_room;
mob_commands.c:    for (wch = char_list; wch != NULL; wch = wch->next) {
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	/*bug( "Mptransfer - Bad syntax: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:		&& d->character->in_room == ch->in_room) {
mob_commands.c:	location = ch->in_room;
mob_commands.c:	       ch->pIndexData->vnum ); */
mob_commands.c:		    ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:   ch->pIndexData->vnum ); */
mob_commands.c:		    ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	   ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:	/*bug( "Mpforce - Bad syntax: vnum %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	    vch_next = vch->next;
mob_commands.c:	    if (vch->in_room == ch->in_room
mob_commands.c:	       ch->pIndexData->vnum ); */
mob_commands.c:		    ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:	       ch->pIndexData->vnum ); */
mob_commands.c:		    ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_commands.c:    if (IS_SET(ch->act, ACT_PET) || IS_AFFECTED(ch, AFF_CHARM))
mob_commands.c:    pArea = ch->in_room->area;
mob_commands.c:	/*bug( "Mpteleport: not in area - %d.", ch->pIndexData->vnum ); */
mob_commands.c:		ch->pIndexData->vnum, ch->name, ch->short_descr);
mob_prog.c:    for (vch = mob->in_room->people; vch; vch = vch->next_in_room)
mob_prog.c:/*       &&  vch->level < MAX_LEVEL-3 */
mob_prog.c:    for (vmob = ch->in_room->people; vmob != NULL; vmob = vmob->next_in_room)
multiclass.c:    for (iClass = 0; ch->class[iClass] != -1; iClass++) {
multiclass.c:	if (ch->level >= skill_table[sn].skill_level[ch->class[iClass]])
multiclass.c:    for (iClass = 0; ch->class[iClass] != -1; iClass++)
multiclass.c:/*  if( ch->class[0] == class )
multiclass.c:    for (iClass = 0; ch->class[iClass] != -1; iClass++) {
multiclass.c:	if (ch->class[iClass] == class)
multiclass.c:    return ch->class[0];
multiclass.c:    for (iClass = 0; ch->class[iClass] != -1; iClass++);
multiclass.c:    for (iClass = 0; ch->class[iClass] != -1; iClass++) {
multiclass.c:	strcat(buf, class_table[ch->class[iClass]].who_long);
multiclass.c:    for (iClass = 0; ch->class[iClass] != -1; iClass++) {
multiclass.c:	strcat(buf, class_table[ch->class[iClass]].who_name);
multiclass.c:    for (iClass = 0; ch->class[iClass] != -1; iClass++) {
multiclass.c:	sprintf(buf2, "%d", ch->class[iClass]);
multiclass.c:	|| (IS_ANTI_RACE(obj, ITEM_ANTI_HUMAN) && ch->race == RACE_HUMAN)
multiclass.c:	    || (IS_ANTI_RACE(obj, ITEM_ANTI_ELF) && ch->race == RACE_ELF)
multiclass.c:	|| (IS_ANTI_RACE(obj, ITEM_ANTI_DWARF) && ch->race == RACE_DWARF)
multiclass.c:	|| (IS_ANTI_RACE(obj, ITEM_ANTI_PIXIE) && ch->race == RACE_PIXIE)
multiclass.c:	    || (IS_ANTI_RACE(obj, ITEM_ANTI_HALFLING) && ch->race == RACE_HALFLING)
multiclass.c:	  || (IS_ANTI_RACE(obj, ITEM_ANTI_DROW) && ch->race == RACE_DROW)
multiclass.c:	|| (IS_ANTI_RACE(obj, ITEM_ANTI_ELDER) && ch->race == RACE_ELDER)
multiclass.c:	  || (IS_ANTI_RACE(obj, ITEM_ANTI_OGRE) && ch->race == RACE_OGRE)
multiclass.c:	    || (IS_ANTI_RACE(obj, ITEM_ANTI_LIZARDMAN) && ch->race == RACE_LIZARDMAN)
multiclass.c:	|| (IS_ANTI_RACE(obj, ITEM_ANTI_DEMON) && ch->race == RACE_DEMON)
multiclass.c:	|| (IS_ANTI_RACE(obj, ITEM_ANTI_GHOUL) && ch->race == RACE_GHOUL)
multiclass.c:	    || (IS_ANTI_RACE(obj, ITEM_ANTI_ILLITHID) && ch->race == RACE_ILLITHID)
multiclass.c:	    || (IS_ANTI_RACE(obj, ITEM_ANTI_MINOTAUR) && ch->race == RACE_MINOTAUR)
multiclass.c:	    || (IS_ANTI_RACE(obj, ITEM_ANTI_SHADOW) && ch->race == RACE_SHADOW)
multiclass.c:	    || (IS_ANTI_RACE(obj, ITEM_ANTI_TABAXI) && ch->race == RACE_TABAXI))
olc.c:    switch (ch->desc->editor) {
olc.c:    switch (ch->desc->editor) {
olc.c:	pArea = (AREA_DATA *) ch->desc->pEdit;
olc.c:	pRoom = ch->in_room;
olc.c:	pObj = (OBJ_INDEX_DATA *) ch->desc->pEdit;
olc.c:	pMob = (MOB_INDEX_DATA *) ch->desc->pEdit;
olc.c:	pMob = (MOB_INDEX_DATA *) ch->desc->inEdit;
olc.c:	pClan = (CLAN_DATA *) ch->desc->pEdit;
olc.c:	pObj = (OBJ_INDEX_DATA *) ch->desc->inEdit;
olc.c:	pRoom = ch->in_room;
olc.c:	    pRoom = ch->in_room;
olc.c:			if (pTrap == (TRAP_DATA *) ch->desc->pEdit)
olc.c:    switch (ch->desc->editor) {
olc.c:    if (ch->desc->editin || ch->desc->inEdit) {
olc.c:	ch->desc->pEdit = ch->desc->inEdit;
olc.c:	ch->desc->inEdit = NULL;
olc.c:	ch->desc->editor = ch->desc->editin;
olc.c:	ch->desc->editin = 0;
olc.c:    if (ch->desc->editor == FORGE_OBJECT)
olc.c:    ch->desc->pEdit = NULL;
olc.c:    ch->desc->editor = 0;
olc.c:    if (!IS_BUILDER(ch, pArea))	/*  && ch->level < L_CON ) */
olc.c:    if (!IS_BUILDER(ch, pArea)) {	/* && ch->level < L_CON ) || 
olc.c:    if (!IS_BUILDER(ch, pArea)) {	/* && ch->level < L_CON ) */
olc.c:    if (!IS_BUILDER(ch, pArea)) {	/* && ch->level < L_CON ) ||
olc.c:    if (!IS_BUILDER(ch, pArea))	/*  && ch->level < L_CON ) */
olc.c:    if (!IS_BUILDER(ch, pArea)) {	/* && ch->level < L_CON ) ||
olc.c:    if (!IS_BUILDER(ch, pArea))	/*  && ch->level < L_CON )  */
olc.c:    if (!IS_BUILDER(ch, pArea)) {	/* && ch->level < L_CON ) || 
olc.c:	pMob = (MOB_INDEX_DATA *) ch->desc->inEdit;
olc.c:    if (!IS_BUILDER(ch, pArea)) {	/*  && ch->level < L_CON ) || 
olc.c:	pMob = (MOB_INDEX_DATA *) ch->desc->inEdit;
olc.c:    switch (ch->desc->editor) {
olc.c:	pArea = ((OBJ_INDEX_DATA *) ch->desc->inEdit)->area;
olc.c:	    for (trap = ch->in_room->traps; trap; trap = trap->next_here)
olc.c:		if (trap == (TRAP_DATA *) ch->desc->pEdit)
olc.c:	pArea = ch->in_room->area;
olc.c:		if ((pExit = ch->in_room->exit[dir])) {
olc.c:		    TRAP_DATA *trap = (TRAP_DATA *) ch->desc->pEdit;
olc.c:   if ( trap == (TRAP_DATA *)ch->desc->pEdit )
olc.c:	    pArea = ch->in_room->area;
olc.c:	bug("Tedit: Invalid editor type %d", ch->desc->editor);
olc.c:    if (!IS_BUILDER(ch, pArea)) {	/*  && ch->level < L_CON ) || 
olc.c:    switch (ch->desc->editor) {
olc.c:	    OBJ_INDEX_DATA *obj = (OBJ_INDEX_DATA *) ch->desc->inEdit;
olc.c:	    ROOM_INDEX_DATA *room = ch->in_room;
olc.c:	    bug("Tedit: NULL pExit in %d", ch->in_room->vnum);
olc.c:	bug("Tedit: Invalid editor %d", ch->desc->editor);
olc.c:    pArea = ch->in_room->area;
olc.c:	if (ch->desc->editor == ED_AREA)
olc.c:	    reset_area((AREA_DATA *) ch->desc->pEdit);
olc.c:	if (ch->desc->editor == ED_AREA)
olc.c:	    purge_area((AREA_DATA *) ch->desc->pEdit);
olc.c:	    ch->desc->editor = ED_AREA;
olc.c:	    pArea = (AREA_DATA *) ch->desc->pEdit;
olc.c:    ch->desc->pEdit = (void *) pArea;
olc.c:    ch->desc->editor = ED_AREA;
olc.c:    pRoom = ch->in_room;
olc.c:	    char_to_room(ch, ch->desc->pEdit);
olc.c:    ch->desc->editor = ED_ROOM;
olc.c:	ch->desc->pEdit = (void *) pObj;
olc.c:	ch->desc->editor = ED_OBJECT;
olc.c:		pArea = ch->in_room->area;
olc.c:	    ch->desc->editor = ED_OBJECT;
olc.c:	ch->desc->pEdit = (void *) pMob;
olc.c:	ch->desc->editor = ED_MOBILE;
olc.c:		pArea = ch->in_room->area;
olc.c:	    ch->desc->editor = ED_MOBILE;
olc.c:	ch->desc->pEdit = (void *) pClan;
olc.c:	ch->desc->editor = ED_CLAN;
olc.c:	    ch->desc->editor = ED_CLAN;
olc.c:	if (!(pMProg = get_mprog_data((MOB_INDEX_DATA *) ch->desc->pEdit,
olc.c:	ch->desc->editin = ch->desc->editor;
olc.c:	ch->desc->editor = ED_MPROG;
olc.c:	ch->desc->inEdit = ch->desc->pEdit;
olc.c:	ch->desc->pEdit = (void *) pMProg;
olc.c:	    ch->desc->editin = ch->desc->editor;
olc.c:	    ch->desc->editor = ED_MPROG;
olc.c:	if (!(pTrap = get_trap_data(ch->desc->pEdit, atoi(command),
olc.c:	ch->desc->editin = ch->desc->editor;
olc.c:	ch->desc->editor = ED_OPROG;
olc.c:	ch->desc->inEdit = ch->desc->pEdit;
olc.c:	ch->desc->pEdit = (void *) pTrap;
olc.c:	ch->desc->editin = ch->desc->editor;
olc.c:	ch->desc->editor = ED_OPROG;
olc.c:	ch->desc->editor = ch->desc->editin;
olc.c:	ch->desc->editin = 0;
olc.c:	if (!(pTrap = get_trap_data(ch->in_room, atoi(command), ED_RPROG))) {
olc.c:	ch->desc->editin = ch->desc->editor;
olc.c:	ch->desc->editor = ED_RPROG;
olc.c:	ch->desc->pEdit = (void *) pTrap;
olc.c:	ch->desc->editin = ch->desc->editor;
olc.c:	ch->desc->editor = ED_RPROG;
olc.c:	ch->desc->editor = ch->desc->editin;
olc.c:	ch->desc->editin = 0;
olc.c:	if (!str_prefix(command, dir_name[dir]) && ch->in_room->exit[dir])
olc.c:	if (!(pTrap = get_trap_data(ch->in_room->exit[dir], atoi(command),
olc.c:	ch->desc->editin = ch->desc->editor;
olc.c:	ch->desc->editor = ED_EPROG;
olc.c:	ch->desc->pEdit = pTrap;
olc.c:	ch->desc->editin = ch->desc->editor;
olc.c:	ch->desc->editor = ED_EPROG;
olc.c:	ch->desc->editor = ch->desc->editin;
olc.c:	ch->desc->editin = 0;
olc.c:	if (ch->in_room->reset_first) {
olc.c:    if (!IS_BUILDER(ch, ch->in_room->area)) {
olc.c:	ROOM_INDEX_DATA *pRoom = ch->in_room;
olc.c:	    if (!ch->in_room->reset_first) {
olc.c:/*        pReset->arg3    = ch->in_room->vnum;
olc.c:   pReset->arg3     = ch->in_room->vnum;
olc.c:   pReset->arg2    = ch->in_room->vnum;
olc.c:   add_reset( ch->in_room, pReset, atoi( arg1 ) );
olc.c:    ch->desc->pEdit = NULL;
olc.c:    ch->desc->editor = ED_MRESET;
olc.c:    ch->desc->inEdit = NULL;
olc.c:    ch->desc->editin = 0;
olc.c:    ch->desc->pEdit = (void *) pSocial;
olc.c:    ch->desc->editor = ED_SOCIAL;
olc.c:    ch->desc->inEdit = NULL;
olc.c:    ch->desc->editin = 0;
olc.c:	ch->desc->pEdit = (void *) pObj;
olc.c:	ch->desc->editor = RENAME_OBJECT;
olc.c:    ch->desc->pEdit = (void *) to_forge;
olc.c:    ch->desc->editor = FORGE_OBJECT;
olc.c:		&& atoi(command) > ch->level / 10) {
olc.c:    if (((ch->money.gold * C_PER_G) + (ch->money.silver * S_PER_G) +
olc.c:	 (ch->money.copper)) < ((obj->cost.gold * C_PER_G) + (obj->cost.silver * S_PER_G) +
olc.c:    spend_money(&ch->money, &obj->cost);
olc.c:    if (ch->gold < obj->cost) {
olc.c:    ch->gold -= obj->cost;
olc.c:    ch->desc->pEdit = (void *) pSpell;
olc.c:    ch->desc->editor = ED_SPEDIT;
olc.c:    ch->desc->inEdit = NULL;
olc.c:    ch->desc->editin = 0;
olc.c:    ch->desc->pEdit = (void *) pNewbie;
olc.c:    ch->desc->editor = ED_NEWBIE;
olc.c:    ch->desc->pEdit = (void *) pRace;
olc.c:    ch->desc->editor = RACE_EDIT;
olc.c:    ch->desc->inEdit = NULL;
olc.c:    ch->desc->editin = 0;
olc_act.c:    pArea = ch->in_room->area;
olc_act.c:    pArea = ch->in_room->area;
olc_act.c:    pArea = ch->in_room->area;
olc_act.c:    pArea = ch->in_room->area;
olc_act.c:	ch->desc->pEdit = (void *) pMob;
olc_act.c:    ch->desc->pEdit = (void *) ch->in_room;
olc_act.c:	ch->desc->pEdit = (void *) pObj;
olc_act.c:    ch->desc->pEdit = (void *) ch->in_room;
olc_act.c:    ch->desc->pEdit = (void *) pArea;
olc_act.c:    if (get_trust(ch) >= L_CON || !str_cmp(ch->guild->name, "CREATION")) {
olc_act.c:    if (get_trust(ch) >= L_CON || !str_cmp(ch->guild->name, "CREATION")) {
olc_act.c:    if (get_trust(ch) >= L_CON || !str_cmp(ch->guild->name, "CREATION")) {
olc_act.c:    if (get_trust(ch) >= L_CON || !str_cmp(ch->guild->name, "CREATION")) {
olc_act.c:    if (value > ch->pcdata->security || value < 0) {
olc_act.c:	if (ch->pcdata->security != 0) {
olc_act.c:	    sprintf(buf, "Security is 0-%d.\n\r", ch->pcdata->security);
olc_act.c:    for (rch = pRoom->people; rch; rch = rch->next_in_room) {
olc_act.c:	one_argument(rch->name, buf);
olc_act.c:	pExit->to_room = ch->in_room;	/* Assign data.         */
olc_act.c:	pExit->vnum = ch->in_room->vnum;
olc_act.c:	    pArea = ch->in_room->area;
olc_act.c:	pArea = ch->in_room->area;
olc_act.c:    ch->desc->pEdit = (void *) pRoom;
olc_act.c:    for (victim = ch->in_room->people; victim; victim = vnext) {
olc_act.c:    for (obj = ch->in_room->contents; obj; obj = obj_next) {
olc_act.c:    ch->desc->pEdit = NULL;
olc_act.c:    ch->desc->editor = 0;
olc_act.c:	for (pMob = ch->in_room->reset_first; pMob; pMob = pMob->next) {
olc_act.c:	pArea = ch->in_room->area;
olc_act.c:    ch->desc->pEdit = (void *) pObj;
olc_act.c:    ch->desc->pEdit = NULL;
olc_act.c:    ch->desc->editor = 0;
olc_act.c:    ch->desc->pEdit = (void *) pClan;
olc_act.c:    if ((pClan = get_clan_index(ch->clan)) != NULL) {
olc_act.c:	pArea = ch->in_room->area;
olc_act.c:    ch->desc->pEdit = (void *) pMob;
olc_act.c:    ch->desc->pEdit = NULL;
olc_act.c:    ch->desc->editor = 0;
olc_act.c:    pMob = (MOB_INDEX_DATA *) ch->desc->inEdit;
olc_act.c:	    if ((pExit = ch->in_room->exit[dir])) {
olc_act.c:    switch (ch->desc->editor) {
olc_act.c:	bug("Tedit_show: Invalid editor %d", ch->desc->editor);
olc_act.c:    ch->desc->inEdit = (void *) ch->desc->pEdit;
olc_act.c:    ch->desc->pEdit = (void *) pMProg;
olc_act.c:    switch (ch->desc->editor) {
olc_act.c:	bug("Tedit_create: Invalid editor %d", ch->desc->editor);
olc_act.c:    if (ch->desc->editor == ED_OPROG)
olc_act.c:	ch->desc->inEdit = (void *) ch->desc->pEdit;
olc_act.c:    ch->desc->pEdit = (void *) pTrap;
olc_act.c:    switch (ch->desc->editor) {
olc_act.c:	ch->desc->pEdit = NULL;
olc_act.c:	ch->desc->editor = 0;
olc_act.c:	    ch->desc->pEdit = NULL;
olc_act.c:	    ch->desc->editor = 0;
olc_act.c:    location = (arg[0] == '\0') ? ch->in_room : find_location(ch, arg);
olc_act.c:	ch->desc->pEdit = NULL;
olc_act.c:	ch->desc->editor = 0;
olc_act.c:	    ch->desc->pEdit = NULL;
olc_act.c:	    ch->desc->editor = 0;
olc_help.c:    if (ch->pcdata->security == 0)
olc_help.c:    if (ch->pcdata->security == 0) {
olc_help.c:		ch->desc->pEdit = (void *) iHelp;
olc_help.c:		ch->desc->editor = ED_HELP;
olc_help.c:	    ch->desc->pEdit = (void *) iHelp;
olc_help.c:	    ch->desc->editor = ED_HELP;
olc_help.c:    ch->desc->pEdit = (void *) NewHelp;
olc_help.c:    ch->desc->editor = ED_HELP;
olc_help.c:	ch->desc->pEdit = NULL;
olc_help.c:	ch->desc->editor = 0;
olc_help.c:	    ch->desc->pEdit = NULL;
olc_help.c:	    ch->desc->editor = 0;
olc_save.c:	switch (ch->desc->editor) {
olc_save.c:	    pArea = (AREA_DATA *) ch->desc->pEdit;
olc_save.c:	    pArea = ch->in_room->area;
olc_save.c:	    pArea = ((OBJ_INDEX_DATA *) ch->desc->pEdit)->area;
olc_save.c:	    pArea = ((MOB_INDEX_DATA *) ch->desc->pEdit)->area;
olc_save.c:	    pArea = ch->in_room->area;
player.c:    for (obj = ch->in_room->contents; obj; obj = obj->next_content)
player.c:    for (obj = ch->carrying; obj != NULL; obj = obj->next_content) {
player.c:    if (ch->in_room->vnum != LOCKER_ROOM) {
player.c:    if (number_percent() < ch->pcdata->learned[gsn_search]) {
player.c:	for (obj = ch->in_room->contents; obj != NULL; obj = obj->next_content) {
player.c:    if (IS_SET(ch->in_room->room2_flags, ROOM_RENTAL)) {
player.c:	if (IS_SET(ch->act2, PLR2_TENNANT)) {
player.c:	REMOVE_BIT(ch->in_room->room2_flags, ROOM_RENTAL);
player.c:	SET_BIT(ch->in_room->room2_flags, ROOM_PRIVATE);
player.c:	SET_BIT(ch->in_room->room2_flags, ROOM_RENTED);
player.c:	SET_BIT(ch->act2, PLR2_TENNANT);
player.c:	ch->money.silver -= 50;
player.c:    if (IS_SET(ch->in_room->room2_flags, ROOM_RENTED)) {
player.c:	if (IS_SET(ch->act2, PLR2_TENNANT)) {
player.c:	    REMOVE_BIT(ch->act2, PLR2_TENNANT);
player.c:	    REMOVE_BIT(ch->in_room->room2_flags, ROOM_RENTED);
player.c:	    SET_BIT(ch->in_room->room2_flags, ROOM_RENTAL);
player.c:	    ch->pcdata->rentroom = 0;
quest.c:	if (IS_SET(ch->act, PLR_QUESTOR)) {
quest.c:	    if ((!ch->questmob && !ch->questobj)
quest.c:		&& ch->questgiver->short_descr != NULL) {
quest.c:		sprintf(buf, "Your quest is ALMOST complete!\n\rGet back to %s before your time runs out!\n\r", ch->questgiver->short_descr);
quest.c:	    } else if (ch->questobj) {
quest.c:			ch->questobj->short_descr);
quest.c:	    } else if (ch->questmob) {
quest.c:			ch->questmob->short_descr);
quest.c:	if (IS_SET(ch->act, PLR_QUESTOR)) {
quest.c:	    if (ch->questobj) {
quest.c:	sprintf(buf, "You have %d quest points.\n\r", ch->questpoints);
quest.c:	if (!IS_SET(ch->act, PLR_QUESTOR)) {
quest.c:	    if (ch->nextquest > 1) {
quest.c:		sprintf(buf, "There are %d minutes remaining until you can go on another quest.\n\r", ch->nextquest);
quest.c:	    } else if (ch->nextquest == 1) {
quest.c:	} else if (ch->countdown > 0) {
quest.c:	    sprintf(buf, "Time left for current quest: %d\n\r", ch->countdown);
quest.c:    for (questman = ch->in_room->people; questman; questman = questman->next_in_room) {
quest.c:    ch->questgiver = questman;
quest.c:		if (ch->questpoints >= quest_table[cnt].qp * amt) {
quest.c:		    if (quest_table[cnt].level <= ch->level) {
quest.c:			ch->questpoints -= quest_table[cnt].qp * amt;
quest.c:			    ch->practice += amt;
quest.c:			sprintf(buf, "Sorry, %s, but you are too inexperienced to use that item.\n\r", ch->name);
quest.c:		    sprintf(buf, "Sorry, %s, but you don't have enough quest points for that.\n\r", ch->name);
quest.c:	    sprintf(buf, "I don't have that item, %s.\n\r", ch->name);
quest.c:	if (IS_SET(ch->act, PLR_QUESTOR)) {
quest.c:	if (ch->nextquest > 0) {
quest.c:	    sprintf(buf, "You're very brave, %s, but let someone else have a chance.", ch->name);
quest.c:	sprintf(buf, "Thank you, brave %s!", ch->name);
quest.c:	if (ch->questmob || ch->questobj) {
quest.c:	    if (ch->questmob)
quest.c:		ch->countdown = number_range(10, 30);	/* time to complete quest */
quest.c:	    if (ch->questobj)
quest.c:		ch->countdown = number_range(20, 45);
quest.c:	    SET_BIT(ch->act, PLR_QUESTOR);
quest.c:	    sprintf(buf, "You have %d minutes to complete this quest.", ch->countdown);
quest.c:	if (ch->questgiver != questman) {
quest.c:	if (IS_SET(ch->act, PLR_QUESTOR)) {
quest.c:	    if ((!ch->questmob && !ch->questobj)
quest.c:		&& ch->countdown > 0) {
quest.c:		    ch->practice += pracreward;
quest.c:		REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.c:		ch->questgiver = NULL;
quest.c:		ch->countdown = 0;
quest.c:		ch->questmob = NULL;
quest.c:		ch->questobj = NULL;
quest.c:		ch->nextquest = 30;	/* 30 */
quest.c:		/*   ch->gold += reward; */
quest.c:		ch->questpoints += pointreward;
quest.c:	    else if (ch->questobj && ch->countdown > 0) {
quest.c:		for (obj = ch->carrying; obj != NULL; obj = obj_next) {
quest.c:		    if (obj == ch->questobj) {
quest.c:			ch->practice += pracreward;
quest.c:		    REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.c:		    ch->questgiver = NULL;
quest.c:		    ch->countdown = 0;
quest.c:		    ch->questmob = NULL;
quest.c:		    ch->questobj = NULL;
quest.c:		    ch->nextquest = 30;		/* 30 min till ch can quest again */
quest.c:		    ch->questpoints += pointreward;
quest.c:	    else if ((ch->questmob || ch->questobj)
quest.c:		     && ch->countdown > 0) {
quest.c:	if (ch->nextquest > 0)
quest.c:	    sprintf(buf, "You have to REQUEST a quest first, %s.", ch->name);
quest.c:	if (IS_SET(ch->act, PLR_QUESTOR)) {
quest.c:	    if (ch->questobj) {
quest.c:			ch->questobj->short_descr);
quest.c:	    } else if (ch->questmob) {
quest.c:			ch->questmob->short_descr);
quest.c:	    sprintf(buf, "You have %d quest points.\n\r", ch->questpoints);
quest.c:	    if (ch->countdown > 0) {
quest.c:		sprintf(buf, "Time left for current quest: %d\n\r", ch->countdown);
quest.c:	if (ch->nextquest > 1) {
quest.c:	    sprintf(buf, "There are %d minutes remaining until you can go on another quest.\n\r", ch->nextquest);
quest.c:	} else if (ch->nextquest == 1) {
quest.c:	vsearch_next = vsearch->next;
quest.c:   && vsearch->pIndexData->vnum == 7 ) 
quest.c:	if (vsearch->deleted)
quest.c:	level_diff = ch->level - vsearch->level;
quest.c:	 && (!IS_SET(vsearch->in_room->area->area_flags, AREA_PROTOTYPE))
quest.c:	  && (!IS_SET(vsearch->in_room->area->area_flags, AREA_NO_QUEST))
quest.c:	    && (vsearch->pIndexData->pShop == NULL)
quest.c:	    && (vsearch->pIndexData->vnum != 1351)	/* Ravenwood guard */
quest.c:	    &&(vsearch->pIndexData->vnum != 1350)	/* Ravenwood guard */
quest.c:	/*                && ( vsearch->pIndexData->vnum != 7 )     Supermob */
quest.c:	    &&(ch->level <= vsearch->in_room->area->ulevel)
quest.c:	    && (ch->level > vsearch->in_room->area->llevel)
quest.c:	    && (!IS_SET(vsearch->act, ACT_TRAIN))
quest.c:	    && (!IS_SET(vsearch->act, ACT_PRACTICE))
quest.c:	    && (!IS_SET(vsearch->in_room->room_flags, ROOM_SAFE))
quest.c:	    && (!IS_SET(vsearch->in_room->room_flags, ROOM_NO_OFFENSIVE)))
quest.c:/*              && ( !IS_SET( vsearch->in_room->area->area_flags, AREA_PROTOTYPE ) ) */
quest.c:   vsearch->name, level_diff, vsearch->in_room->area->name,
quest.c:   ( IS_SET( vsearch->in_room->area->area_flags, AREA_NO_QUEST ) ) ? 'Y' : 'N' );
quest.c:	ch->nextquest = 10;	/* 10 min until ch can quest again */
quest.c:	ch->nextquest = 10;	/* 10 min until ch can quest again */
quest.c:	questitem = create_object(get_obj_index(objvnum), ch->level);
quest.c:	ch->questobj = questitem;
quest.c:	ch->questmob = victim;
quest.c:	ch_next = ch->next;
quest.c:	if (ch->nextquest > 0) {
quest.c:	    ch->nextquest--;
quest.c:	    if (ch->nextquest == 0) {
quest.c:	} else if (IS_SET(ch->act, PLR_QUESTOR)) {
quest.c:	    if (ch->questmob
quest.c:		&& ch->questmob->deleted
quest.c:		&& ch->countdown > 1) {
quest.c:		 ch->questgiver->short_descr, ch->questmob->short_descr);
quest.c:		 ch->questgiver->short_descr, ch->questmob->short_descr);
quest.c:		ch->reply = ch->questgiver;
quest.c:		REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.c:		ch->questgiver = NULL;
quest.c:		ch->questmob = NULL;
quest.c:		ch->countdown = 0;
quest.c:		ch->nextquest = 15;	/* 15 min until ch can quest again */
quest.c:	    if (--ch->countdown <= 0) {
quest.c:		ch->nextquest = 30;	/* 30 min until ch can quest again */
quest.c:		sprintf(buf, "You have run out of time for your quest!\n\rYou may quest again in %d minutes.\n\r", ch->nextquest);
quest.c:		REMOVE_BIT(ch->act, PLR_QUESTOR);
quest.c:		if (ch->questobj)
quest.c:		    ch->questobj->timer = 1;	/* have obj_update
quest.c:		ch->questgiver = NULL;
quest.c:		ch->countdown = 0;
quest.c:		ch->questmob = NULL;
quest.c:		ch->questobj = NULL;
quest.c:	    if (ch->countdown > 0 && ch->countdown < 6) {
raceskill.c:    if (ch->race != RACE_MINOTAUR) {
raceskill.c:    if (ch->race_wait > 0)
raceskill.c:    if (!ch->fighting) {
raceskill.c:    victim = ch->fighting;
raceskill.c:    mod = ch->level / 5;
raceskill.c:    ch->race_wait = timer;
raceskill.c:    dmg = number_range(ch->level, ch->level * 5);
raceskill.c:    if (victim->position == POS_DEAD || ch->in_room != victim->in_room)
raceskill.c:    if (ch->race != RACE_DROW) {
raceskill.c:	if (!(victim = ch->fighting)) {
raceskill.c:    af.level = ch->level;
raceskill.c:    af.duration = ch->level / 10;
raceskill.c:    af.modifier = 5 * ch->level;
raceskill.c:    af.modifier = 0 - ch->level / 5;
raceskill.c:    if (ch->race != RACE_DROW) {
raceskill.c:	for (pd = ch->powered; pd; pd = pd->next) {
raceskill.c:	if (!is_raffected(ch->in_room, gsn_globedark)) {
raceskill.c:	for (pd = ch->powered; pd; pd = pd->next) {
raceskill.c:		if (pd->room == ch->in_room) {
raceskill.c:		    raffect_remove(ch->in_room, ch, pd->raf);
raceskill.c:	if (is_raffected(ch->in_room, gsn_globedark)) {
raceskill.c:	raf.room = ch->in_room;
raceskill.c:	raffect_to_room(ch->in_room, ch, &raf);
raceskill.c:    if (ch->race != RACE_DWARF) {
raceskill.c:	sprintf(buf, "  lvl = minimum 30, maximum %d.\n\r", ch->level);
raceskill.c:    if (ch->in_room->vnum != ROOM_VNUM_SMITHY) {
raceskill.c:    for (hammer = ch->carrying; hammer; hammer = hammer->next) {
raceskill.c:    if (wear && antirace && (lvl < 30 || lvl > ch->level)) {
raceskill.c:	sprintf(buf, "Illegal level.  Valid levels are 30 to %d.\n\r", ch->level);
raceskill.c:	if ((ch->money.gold + (ch->money.silver / SILVER_PER_GOLD) +
raceskill.c:	     (ch->money.copper / COPPER_PER_GOLD)) < (lvl * 100)) {
raceskill.c:	if (ch->gold < lvl * 10000) {
raceskill.c:    if (ch->race != RACE_LIZARDMAN) {
raceskill.c:    if (ch->race_wait > 0)
raceskill.c:    if (!ch->fighting) {
raceskill.c:    victim = ch->fighting;
raceskill.c:    dam = ch->level + number_range(ch->level, ch->level * 4);
raceskill.c:    ch->race_wait = 36;
raceskill.c:	|| victim->in_room != ch->in_room)
raceskill.c:		    af.level = ch->level;
raceskill.c:    if (!saves_spell(ch->level, victim) && victim->race != RACE_GHOUL) {
raceskill.c:	af.level = ch->level;
save.c:    if (IS_NPC(ch) || ch->level < 2)
save.c:    if (ch->desc && ch->desc->original)
save.c:	ch = ch->desc->original;
save.c:    ch->save_time = current_time;
save.c:    sprintf(strsave, "%s%c/%s", PLAYER_DIR, LOWER(ch->name[0]),
save.c:	    capitalize(ch->name));
save.c:    sprintf(strsave, "%s%s", PLAYER_DIR, capitalize(ch->name));
save.c:	sprintf(buf, "Save_char_obj: fopen %s: ", ch->name);
save.c:	if (ch->carrying)
save.c:	    fwrite_obj(ch, ch->carrying, fp, 0, FALSE);
save.c:	if (!IS_NPC(ch) && ch->pcdata->storage)
save.c:	    fwrite_obj(ch, ch->pcdata->storage, fp, 0, TRUE);
save.c:	for (pet = ch->in_room->people; pet; pet = pet->next_in_room) {
save.c:    fprintf(fp, "Nm          %s~\n", ch->name);
save.c:    if (ch->pcdata->lname && ch->pcdata->lname[0] != '\0')
save.c:	fprintf(fp, "Lnm         %s~\n", ch->pcdata->lname);
save.c:    fprintf(fp, "ShtDsc      %s~\n", ch->short_descr);
save.c:    fprintf(fp, "LngDsc      %s~\n", ch->long_descr);
save.c:    fprintf(fp, "Dscr        %s~\n", ch->description);
save.c:    fprintf(fp, "Prmpt       %s~\n", ch->prompt);
save.c:    fprintf(fp, "Sx          %d\n", ch->sex);
save.c:    fprintf(fp, "Rce         %d\n", ch->race);
save.c:    fprintf(fp, "Wiznet      %d\n", ch->wiznet);
save.c:    fprintf(fp, "Clan        %d\n", ch->clan);
save.c:    fprintf(fp, "Clvl        %d\n", ch->clev);
save.c:    fprintf(fp, "Ctmr        %d\n", ch->ctimer);
save.c:	    ch->stunned[0], ch->stunned[1], ch->stunned[2],
save.c:	    ch->stunned[3], ch->stunned[4]);
save.c:    fprintf(fp, "WizLev      %d\n", ch->wizinvis);
save.c:    fprintf(fp, "ClkLev      %d\n", ch->cloaked);
save.c:    fprintf(fp, "Lvl         %d\n", ch->level);
save.c:    fprintf(fp, "Antidisarm  %d\n", ch->antidisarm);
save.c:    fprintf(fp, "Trst        %d\n", ch->trust);
save.c:    fprintf(fp, "Security    %d\n", ch->pcdata->security);	/* OLC */
save.c:    fprintf(fp, "Wizbt       %d\n", ch->wizbit);
save.c:    if (ch->pcdata->host)
save.c:	fprintf(fp, "Host %s~\n", ch->pcdata->host);
save.c:	    ch->played + (int) (current_time - ch->logon));
save.c:	    (ch->in_room == get_room_index(ROOM_VNUM_LIMBO)
save.c:	     && ch->was_in_room)
save.c:	    ? ch->was_in_room->vnum
save.c:	    : ch->in_room->vnum);
save.c:	    ch->hit, ch->perm_hit, ch->mod_hit, ch->mana, ch->perm_mana,
save.c:	    ch->mod_mana, ch->move, ch->perm_move, ch->mod_move, ch->bp,
save.c:	    ch->perm_bp, ch->mod_bp);
save.c:    fprintf(fp, "Charisma    %d\n", ch->charisma);
save.c:    fprintf(fp, "Gold	      %d\n", ch->money.gold);
save.c:    fprintf(fp, "Silver      %d\n", ch->money.silver);
save.c:    fprintf(fp, "Copper      %d\n", ch->money.copper);
save.c:    fprintf(fp, "Gold        %d\n", ch->gold);
save.c:    fprintf(fp, "GRank       %d\n", ch->guild_rank);
save.c:	    (ch->guild != NULL) ? ch->guild->name : "\0");
save.c:    fprintf(fp, "Exp         %d\n", ch->exp);
save.c:    if (ch->race == RACE_GHOUL && !IS_SET(ch->act, PLR_UNDEAD))
save.c:	SET_BIT(ch->act, PLR_UNDEAD);
save.c:    fprintf(fp, "Act         %d\n", ch->act);
save.c:    fprintf(fp, "Act2        %d\n", ch->act2);
save.c:    fprintf(fp, "AffdBy      %ld\n", ch->affected_by);
save.c:    fprintf(fp, "AffdBy2     %ld\n", ch->affected_by2);
save.c:    fprintf(fp, "ImmBits     %ld\n", ch->imm_flags);
save.c:    fprintf(fp, "ResBits     %ld\n", ch->res_flags);
save.c:    fprintf(fp, "VulBits     %ld\n", ch->vul_flags);
save.c:	    ch->position == POS_FIGHTING ? POS_STANDING : ch->position);
save.c:    fprintf(fp, "Prac        %d\n", ch->practice);
save.c:    fprintf(fp, "SavThr      %d\n", ch->saving_throw);
save.c:    fprintf(fp, "Align       %d\n", ch->alignment);
save.c:    fprintf(fp, "SAlign      %c\n", ch->start_align);
save.c:    fprintf(fp, "Hit         %d\n", ch->hitroll);
save.c:    fprintf(fp, "Dam         %d\n", ch->damroll);
save.c:    fprintf(fp, "Armr        %d\n", ch->armor);
save.c:    fprintf(fp, "Wimp        %d\n", ch->wimpy);
save.c:    fprintf(fp, "Deaf        %d\n", ch->deaf);
save.c:    fprintf(fp, "Email	      %s~\n", ch->pcdata->email);
save.c:    fprintf(fp, "Plan	      %s~\n", ch->pcdata->plan);
save.c:    fprintf(fp, "Corpses     %d\n", ch->pcdata->corpses);
save.c:    if (ch->pcdata->rentroom != 0)
save.c:	fprintf(fp, "Rroom %d\n", ch->pcdata->rentroom);
save.c:    if (ch->cquestpnts != 0)
save.c:	fprintf(fp, "Cquestpnts  %d\n", ch->cquestpnts);
save.c:    if (ch->questpoints != 0)
save.c:	fprintf(fp, "QuestPnts   %d\n", ch->questpoints);
save.c:    if (ch->nextquest != 0)
save.c:	fprintf(fp, "QuestNext   %d\n", ch->nextquest);
save.c:    else if (ch->countdown != 0)
save.c:	fprintf(fp, "Vnum        %d\n", ch->pIndexData->vnum);
save.c:	fprintf(fp, "Paswd       %s~\n", ch->pcdata->pwd);
save.c:	fprintf(fp, "Bmfin       %s~\n", ch->pcdata->bamfin);
save.c:	fprintf(fp, "Bmfout      %s~\n", ch->pcdata->bamfout);
save.c:	fprintf(fp, "Bmfsee      %s~\n", ch->pcdata->bamfusee);
save.c:	fprintf(fp, "Trnsto      %s~\n", ch->pcdata->transto);
save.c:	fprintf(fp, "Trnsfrom    %s~\n", ch->pcdata->transfrom);
save.c:	fprintf(fp, "Trnvict     %s~\n", ch->pcdata->transvict);
save.c:	fprintf(fp, "Slyuc       %s~\n", ch->pcdata->slayusee);
save.c:	fprintf(fp, "Slyrm       %s~\n", ch->pcdata->slayroom);
save.c:	fprintf(fp, "Slyvict     %s~\n", ch->pcdata->slayvict);
save.c:	fprintf(fp, "Afkmes      %s~\n", ch->pcdata->afkchar);
save.c:		ch->pcdata->bankaccount.gold,
save.c:		ch->pcdata->bankaccount.silver,
save.c:		ch->pcdata->bankaccount.copper);
save.c:	fprintf(fp, "Bank        %d\n", ch->pcdata->bankaccount);
save.c:	fprintf(fp, "Ttle        %s~\n", ch->pcdata->title);
save.c:	fprintf(fp, "Whotype	  %s~\n", ch->pcdata->whotype);
save.c:		ch->pcdata->perm_str,
save.c:		ch->pcdata->perm_int,
save.c:		ch->pcdata->perm_wis,
save.c:		ch->pcdata->perm_dex,
save.c:		ch->pcdata->perm_con);
save.c:		ch->pcdata->mod_str,
save.c:		ch->pcdata->mod_int,
save.c:		ch->pcdata->mod_wis,
save.c:		ch->pcdata->mod_dex,
save.c:		ch->pcdata->mod_con);
save.c:		ch->pcdata->condition[0],
save.c:		ch->pcdata->condition[1],
save.c:		ch->pcdata->condition[2]);
save.c:	fprintf(fp, "Pglen       %d\n", ch->pcdata->pagelen);
save.c:	fprintf(fp, "Empower     %s~\n", ch->pcdata->empowerments);
save.c:	fprintf(fp, "Detract     %s~\n", ch->pcdata->detractments);
save.c:	fprintf(fp, "Ignore      %s~\n", ch->pcdata->ignore);
save.c:            fprintf (fp, "%s %ld ", boards[i].short_name, ch->pcdata->last_note[i]);
save.c:	    if (skill_table[sn].name && ch->pcdata->learned[sn] > 0) {
save.c:			ch->pcdata->learned[sn], skill_table[sn].name);
save.c:    for (paf = ch->affected; paf; paf = paf->next) {
save.c:    for (paf = ch->affected2; paf; paf = paf->next) {
save.c:    if (ch->pcdata && ch->pcdata->alias_list) {
save.c:	for (pAl = ch->pcdata->alias_list; pAl; pAl = pAl->next)
save.c:    if (ch->level < obj->level
save.c:	ch->pcdata = alloc_perm(sizeof(*ch->pcdata));
save.c:	ch->pcdata = pcdata_free;
save.c:    *ch->pcdata = pcdata_zero;
save.c:    ch->desc = d;
save.c:    ch->name = str_dup(name);
save.c:    ch->prompt = str_dup(daPrompt);
save.c:    ch->wiznet = WIZ_PREFIX;
save.c:    ch->act = PLR_BLANK
save.c:    ch->act2 = 0;
save.c:    ch->pcdata->lname = NULL;	/* str_dup( "" );   &str_empty[0]; */
save.c:    ch->pcdata->board = &boards[DEFAULT_BOARD];
save.c:    ch->pcdata->pwd = str_dup("");
save.c:    ch->pcdata->bamfin = str_dup("");
save.c:    ch->pcdata->bamfout = str_dup("");
save.c:    ch->pcdata->bamfusee = str_dup("");
save.c:    ch->pcdata->transto = str_dup("");
save.c:    ch->pcdata->transfrom = str_dup("");
save.c:    ch->pcdata->transvict = str_dup("");
save.c:    ch->pcdata->slayusee = str_dup("");
save.c:    ch->pcdata->slayroom = str_dup("");
save.c:    ch->pcdata->slayvict = str_dup("");
save.c:    ch->pcdata->afkchar = str_dup("");
save.c:    ch->pcdata->title = str_dup("");
save.c:    ch->pcdata->perm_str = 13;
save.c:    ch->pcdata->perm_int = 13;
save.c:    ch->pcdata->perm_wis = 13;
save.c:    ch->pcdata->perm_dex = 13;
save.c:    ch->pcdata->perm_con = 13;
save.c:    ch->pcdata->condition[COND_THIRST] = MAX_THIRST;	/*  48  */
save.c:    ch->pcdata->condition[COND_FULL] = MAX_FULL;	/*  48  */
save.c:    ch->pcdata->pagelen = 30;
save.c:    ch->pcdata->security = 0;	/* OLC */
save.c:    ch->pcdata->ignore			= str_dup( "" );
save.c:    ch->pcdata->switched = FALSE;
save.c:    ch->combat_timer = 0;	/* XOR */
save.c:    ch->summon_timer = 0;	/* XOR */
save.c:    ch->imm_flags = 0;		/* XOR */
save.c:    ch->res_flags = 0;		/* XOR */
save.c:    ch->vul_flags = 0;		/* XOR */
save.c:    ch->guild = NULL;		/* XOR */
save.c:    ch->pcdata->bankaccount.gold = 0;
save.c:    ch->pcdata->bankaccount.silver = 0;
save.c:    ch->pcdata->bankaccount.copper = 0;
save.c:    ch->pcdata->bankaccount = 0;	/* TRI */
save.c:    ch->pcdata->alias_list = NULL;	/* TRI */
save.c:    ch->pcdata->corpses = 0;
save.c:    ch->pcdata->empowerments = str_dup("");
save.c:    ch->pcdata->detractments = str_dup("");
save.c:    sprintf(strsave, "%s%c/%s.gz", PLAYER_DIR, LOWER(ch->name[0]),
save.c:    sprintf(strsave, "%s%c/%s", PLAYER_DIR, LOWER(ch->name[0]),
save.c:	    KEY("Act", ch->act, fread_number(fp));
save.c:	    KEY("Act2", ch->act2, fread_number(fp));
save.c:	    KEY("AffdBy", ch->affected_by, fread_number(fp));
save.c:	    KEY("AffdBy2", ch->affected_by2, fread_number(fp));
save.c:	    KEY("Afkmes", ch->pcdata->afkchar, fread_string(fp, &stat));
save.c:	    KEY("Align", ch->alignment, fread_number(fp));
save.c:	    KEY("Antidisarm", ch->antidisarm, fread_number(fp));
save.c:	    KEY("Armr", ch->armor, fread_number(fp));
save.c:		paf->next = ch->affected;
save.c:		ch->affected = paf;
save.c:		paf->next = ch->affected2;
save.c:		ch->affected2 = paf;
save.c:		if (!ch->pcdata) {
save.c:		pAl->next = ch->pcdata->alias_list;
save.c:		ch->pcdata->alias_list = pAl;
save.c:		ch->pcdata->mod_str = fread_number(fp);
save.c:		ch->pcdata->mod_int = fread_number(fp);
save.c:		ch->pcdata->mod_wis = fread_number(fp);
save.c:		ch->pcdata->mod_dex = fread_number(fp);
save.c:		ch->pcdata->mod_con = fread_number(fp);
save.c:		ch->pcdata->perm_str = fread_number(fp);
save.c:		ch->pcdata->perm_int = fread_number(fp);
save.c:		ch->pcdata->perm_wis = fread_number(fp);
save.c:		ch->pcdata->perm_dex = fread_number(fp);
save.c:		ch->pcdata->perm_con = fread_number(fp);
save.c:	    KEY("Bmfin", ch->pcdata->bamfin, fread_string(fp, &stat));
save.c:	    KEY("Bmfout", ch->pcdata->bamfout, fread_string(fp, &stat));
save.c:	    KEY("Bmfsee", ch->pcdata->bamfusee, fread_string(fp, &stat));
save.c:		ch->pcdata->bankaccount.gold = fread_number(fp);
save.c:		ch->pcdata->bankaccount.silver = fread_number(fp);
save.c:		ch->pcdata->bankaccount.copper = fread_number(fp);
save.c:	    KEY("Bank", ch->pcdata->bankaccount, fread_number(fp));
save.c:                         ch->name, boardname);
save.c:                      ch->pcdata->last_note[i] = fread_number (fp);
save.c:	    KEY("Charisma", ch->charisma, fread_number(fp));
save.c:	    KEY("Corpses", ch->pcdata->corpses, fread_number(fp));
save.c:	    KEY("Clan", ch->clan, fread_number(fp));
save.c:	    KEY("Clvl", ch->clev, fread_number(fp));
save.c:	    KEY("Copper", ch->money.copper, fread_number(fp));
save.c:	    KEY("Ctmr", ch->ctimer, fread_number(fp));
save.c:		    ch->class[iClass] = -1;
save.c:		    ch->class[iClass] = fread_number(fp);
save.c:		    if (ch->class[iClass] == -1)
save.c:	    KEY("ClkLev", ch->cloaked, fread_number(fp));
save.c:	    KEY("Cquestpnts", ch->cquestpnts, fread_number(fp));
save.c:		ch->pcdata->condition[0] = fread_number(fp);
save.c:		ch->pcdata->condition[1] = fread_number(fp);
save.c:		ch->pcdata->condition[2] = fread_number(fp);
save.c:	    KEY("Dam", ch->damroll, fread_number(fp));
save.c:	    KEY("Deaf", ch->deaf, fread_number(fp));
save.c:	    KEY("Detract", ch->pcdata->detractments, fread_string(fp, &stat));
save.c:	    KEY("Dscr", ch->description, fread_string(fp, &stat));
save.c:	    KEY("Email", ch->pcdata->email, fread_string(fp, &stat));
save.c:	    KEY("Empower", ch->pcdata->empowerments, fread_string(fp, &stat));
save.c:/*              if ( ch->trust > 107 && ch->level < 108 && !IS_CODER(ch) )
save.c:   ch->trust = 0; */
save.c:		    REMOVE_BIT(ch->affected_by2, CODER);
save.c:	    KEY("Exp", ch->exp, fread_number(fp));
save.c:	    KEY("Gold", ch->money.gold, fread_number(fp));
save.c:	    KEY("Gold", ch->gold, fread_number(fp));
save.c:	    KEY("GRank", ch->guild_rank, fread_number(fp));
save.c:			ch->guild = (GUILD_DATA *) & (guild_table[i]);
save.c:	    KEY("Hit", ch->hitroll, fread_number(fp));
save.c:	    KEY("Host", ch->pcdata->host, fread_string(fp, &stat));
save.c:		ch->hit = fread_number(fp);
save.c:		ch->perm_hit = fread_number(fp);
save.c:		ch->mod_hit = fread_number(fp);
save.c:		ch->mana = fread_number(fp);
save.c:		ch->perm_mana = fread_number(fp);
save.c:		ch->mod_mana = fread_number(fp);
save.c:		ch->move = fread_number(fp);
save.c:		ch->perm_move = fread_number(fp);
save.c:		ch->mod_move = fread_number(fp);
save.c:		ch->bp = fread_number(fp);
save.c:		ch->perm_bp = fread_number(fp);
save.c:		ch->mod_bp = fread_number(fp);
save.c:	    KEY("ImmBits", ch->imm_flags, fread_number(fp));
save.c:	    KEY("Ignore",  ch->pcdata->ignore, fread_string(fp, &stat));
save.c:	    KEY("Lnm", ch->pcdata->lname, fread_string(fp, &stat));
save.c:	    KEY("Lvl", ch->level, fread_number(fp));
save.c:	    KEY("Pglen", ch->pcdata->pagelen, fread_number(fp));
save.c:	    KEY("Paswd", ch->pcdata->pwd, fread_string(fp, &stat));
save.c:	    KEY("Playd", ch->played, fread_number(fp));
save.c:	    KEY("Plan", ch->pcdata->plan, fread_string(fp, &stat));
save.c:	    KEY("Pos", ch->position, fread_number(fp));
save.c:	    KEY("Prac", ch->practice, fread_number(fp));
save.c:	    KEY("Prmpt", ch->prompt, fread_string(fp, &stat));
save.c:	    KEY("QuestPnts", ch->questpoints, fread_number(fp));
save.c:	    KEY("QuestNext", ch->nextquest, fread_number(fp));
save.c:	    KEY("Rce", ch->race, fread_number(fp));
save.c:	    KEY("ResBits", ch->res_flags, fread_number(fp));
save.c:	    KEY("Rroom", ch->pcdata->rentroom, fread_number(fp));
save.c:		ch->in_room = get_room_index(fread_number(fp));
save.c:		if (!ch->in_room)
save.c:		    ch->in_room = get_room_index(ROOM_VNUM_LIMBO);
save.c:	    KEY("SavThr", ch->saving_throw, fread_number(fp));
save.c:	    KEY("SAlign", ch->start_align, fread_letter(fp));
save.c:	    KEY("Sx", ch->sex, fread_number(fp));
save.c:	    KEY("Silver", ch->money.silver, fread_number(fp));
save.c:	    KEY("Slyuc", ch->pcdata->slayusee, fread_string(fp, &stat));
save.c:	    KEY("Slyrm", ch->pcdata->slayroom, fread_string(fp, &stat));
save.c:	    KEY("Slyvict", ch->pcdata->slayvict, fread_string(fp, &stat));
save.c:		ch->stunned[0] = fread_number(fp);
save.c:		ch->stunned[1] = fread_number(fp);
save.c:		ch->stunned[2] = fread_number(fp);
save.c:		ch->stunned[3] = fread_number(fp);
save.c:		ch->stunned[4] = fread_number(fp);
save.c:	    KEY("Security", ch->pcdata->security, fread_number(fp));	/* OLC */
save.c:		    ch->pcdata->learned[sn] = value;
save.c:	    KEY("Trst", ch->trust, fread_number(fp));
save.c:	    KEY("Trnsto", ch->pcdata->transto, fread_string(fp, &stat));
save.c:	    KEY("Trnsfrom", ch->pcdata->transfrom, fread_string(fp, &stat));
save.c:	    KEY("Trnvict", ch->pcdata->transvict, fread_string(fp, &stat));
save.c:		ch->pcdata->title = fread_string(fp, &stat);
save.c:		if (isalpha(ch->pcdata->title[0])
save.c:		    || isdigit(ch->pcdata->title[0])) {
save.c:		    sprintf(buf, " %s", ch->pcdata->title);
save.c:		    free_string(ch->pcdata->title);
save.c:		    ch->pcdata->title = str_dup(buf);
save.c:	    KEY("VulBits", ch->vul_flags, fread_number(fp));
save.c:		ch->pIndexData = get_mob_index(fread_number(fp));
save.c:	    KEY("Wiznet", ch->wiznet, fread_number(fp));
save.c:	    KEY("Wimp", ch->wimpy, fread_number(fp));
save.c:	    KEY("Wizbt", ch->wizbit, fread_number(fp));
save.c:	    KEY("WizLev", ch->wizinvis, fread_number(fp));
save.c:	    KEY("Whotype", ch->pcdata->whotype, fread_string(fp, &stat));
save.c:	if (!ch->pcdata->pagelen)
save.c:	    ch->pcdata->pagelen = 30;
save.c:	if (!ch->prompt || ch->prompt == '\0')
save.c:	    ch->prompt = str_dup(daPrompt);
save.c:	if (ch->pcdata->pagelen > 60)
save.c:	    ch->pcdata->pagelen = 60;
save.c:	    KEY("Wiznet", ch->wiznet, fread_number(fp));
save.c:    char_to_room(pet, ch->in_room);
save.c:    iAl = ch->pcdata->alias_list;
save.c:    for (pAl = ch->pcdata->alias_list; pAl; pAl = pAl->next) {
save.c: * Assumes ch->pcdata->corpses & that it is initialized to 0.
save.c:    sprintf(strsave, "%s%c/%s.cps", PLAYER_DIR, LOWER(ch->name[0]),
save.c:	    capitalize(ch->name));
save.c:    sprintf(strsave, "%s%s.cps", PLAYER_DIR, capitalize(ch->name));
save.c:	sprintf(buf, "Corpse back: fopen %s: ", ch->name);
save.c:    ch->pcdata->corpses = 1;
save.c:   sprintf( buf, "Corpse back: fopen %s: ", ch->name );
save.c:   sprintf( buf, "Corpse back: fopen %s: ", ch->name );
save.c:    if (IS_NPC(ch) || ch->level < 2)
save.c:    if (ch->desc && ch->desc->original)
save.c:	ch = ch->desc->original;
save.c:    sprintf(fingsave, "%s%c/%s.fng", PLAYER_DIR, LOWER(ch->name[0]),
save.c:	    capitalize(ch->name));
save.c:	sprintf(buf, "Save_finger_Info: fopen %s ", ch->name);
save.c:    fprintf(fp, "Name: %s\n", ch->name);
save.c:    fprintf(fp, "Clan: %s\n", get_clan_index(ch->clan)->name);
save.c:    fprintf(fp, "Level: %-16d", ch->level);
save.c:    fprintf(fp, "Sex: %s\n", ch->sex == SEX_MALE ? "male" :
save.c:	    ch->sex == SEX_FEMALE ? "female" : "neutral");
save.c:    fprintf(fp, "Race: %s\n", (get_race_data(ch->race))->race_name);
save.c:	fprintf(fp, "Thief: %s\n", (IS_SET(ch->act, PLR_THIEF)) ? "Yes"
save.c:/*  fprintf( fp, "Mobs Killed: %-10d",   ch->pcdata->kills      );
save.c:   fprintf( fp, "Deaths: %d\n\n",          ch->pcdata->died     ); */
save.c:    fprintf(fp, "Title: %s\n", ch->pcdata->title);
save.c:    fprintf(fp, "Email: %s\n", ch->pcdata->email);
save.c:    fprintf(fp, "Plan: %s\n", ch->pcdata->plan);
save.c:    fprintf(fp, "Last On: %s~\n", (char *) ctime(&ch->logon));
scan.c:    if (scan_room(ch, ch->in_room, buf) == 0) {
scan.c:	room = ch->in_room;	/* Sets the starting point, feeds the for loop */
scan.c: scan_list(ch->in_room, ch, 0, -1);
scan.c: scan_room = ch->in_room;
scan.c: for (rch=scan_room->people; rch != NULL; rch=rch->next_in_room)
scan.c: if (!IS_NPC(rch) && rch->invis_level > get_trust(ch)) continue;
special.c:    if (ch->position != POS_FIGHTING)
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim);
special.c:    if (ch->position != POS_FIGHTING)
special.c:    if (ch->position != POS_FIGHTING)
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, NULL);
special.c:    if (!IS_AWAKE(ch) || ch->fighting)
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:	spell_armor(skill_lookup("armor"), ch->level, ch, victim);
special.c:	spell_bless(skill_lookup("bless"), ch->level, ch, victim);
special.c:			     ch->level, ch, victim);
special.c:			 ch->level, ch, victim);
special.c:			  ch->level, ch, victim);
special.c:	spell_refresh(skill_lookup("refresh"), ch->level, ch, victim);
special.c:    if (ch->fighting)
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:	spell_armor(skill_lookup("armor"), ch->level, ch, victim);
special.c:	spell_bless(skill_lookup("bless"), ch->level, ch, victim);
special.c:			     ch->level, ch, victim);
special.c:			 ch->level, ch, victim);
special.c:			  ch->level, ch, victim);
special.c:	spell_refresh(skill_lookup("refresh"), ch->level, ch, victim);
special.c:	spell_shield(skill_lookup("shield"), ch->level, ch, victim);
special.c:	spell_heal(skill_lookup("heal"), ch->level, ch, victim);
special.c:    if (ch->position != POS_FIGHTING) {
special.c:	(*skill_table[sn].spell_fun) (sn, ch->level, ch, ch);
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:	if (ch->level >= min_level)
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim);
special.c:    if (ch->position != POS_FIGHTING)
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim);
special.c:    if (ch->position != POS_FIGHTING)
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:	if (ch->level >= min_level)
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim);
special.c:    if (ch->position != POS_FIGHTING)
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:	if (ch->level >= min_level)
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim);
special.c:    if (!IS_AWAKE(ch) || ch->fighting)
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:    char_to_room(guard, ch->in_room);
special.c:    guard->fighting = ch->fighting;
special.c:    char_to_room(guard, ch->in_room);
special.c:    guard->fighting = ch->fighting;
special.c:   ch->in_room );
special.c:   ch->in_room ); */
special.c:    for (corpse = ch->in_room->contents; corpse; corpse = corpse_next) {
special.c:	    obj_to_room(obj, ch->in_room);
special.c:    if (!IS_AWAKE(ch) || ch->fighting)
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:    for (trash = ch->in_room->contents; trash; trash = trash_next) {
special.c:    if (ch->fighting)
special.c:    if (!move || ch->position < POS_SLEEPING)
special.c:	ch->position = POS_STANDING;
special.c:	ch->position = POS_SLEEPING;
special.c:    if (ch->position != POS_FIGHTING
special.c:	|| !(victim = ch->fighting)
special.c:	|| number_percent() > 2 * ch->level)
special.c:    spell_poison(gsn_poison, ch->level, ch, victim);
special.c:    if (ch->position == POS_FIGHTING) {
special.c:	if (ch->level < 40)
special.c:	victim = ch->fighting;
special.c:    if (ch->position != POS_STANDING)
special.c:    for (victim = ch->in_room->people; victim;
special.c:	if (IS_AWAKE(victim) && number_percent() >= ch->level) {
special.c:	    ch->money.gold += 7 * amount.gold / 8;
special.c:	    ch->money.silver += 7 * amount.silver / 8;
special.c:	    ch->money.copper += 7 * amount.copper / 8;
special.c:	    ch->gold += 7 * gold / 8;
special.c:    if (ch->position != POS_STANDING)
special.c:    if (ch->fighting)
special.c:    for (victim = ch->in_room->people; victim;
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, ch);
special.c:    if ((ch->position == POS_FIGHTING)
special.c:	char_to_room(demon, ch->in_room);
special.c:	fch = ch->fighting;
special.c:	demon->fighting = ch->fighting;
special.c:	fch->fighting = demon;
special.c:    if (ch->fighting)
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, ch);
special.c:    if ((ch->position == POS_FIGHTING)
special.c:	char_to_room(light, ch->in_room);
special.c:	fch = ch->fighting;
special.c:	light->fighting = ch->fighting;
special.c:	fch->fighting = light;
special.c:    if (ch->fighting)
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, ch);
special.c:    if (ch->position != POS_FIGHTING)
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:	if (ch->level >= min_level)
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim);
special.c:	!IS_SET(ch->in_room->room_flags, ROOM_DARK)) {
special.c:	if (!ch->in_room) {
special.c:    if (ch->position != POS_FIGHTING)
special.c:    for (victim = ch->in_room->people; victim; victim = victim->next_in_room) {
special.c:	if (ch->level >= min_level)
special.c:    (*skill_table[sn].spell_fun) (sn, ch->level, ch, victim);
special.c:    if (!(pexit = ch->in_room->exit[door]))
special.c:	    && pexit_rev->to_room == ch->in_room) {
special.c:	    for (rch = to_room->people; rch; rch = rch->next_in_room)
string.c:    ch->desc->pString = pString;
string.c:    ch->desc->pString = pString;
string.c:	    **ch->desc->pString = '\0';
string.c:	    *ch->desc->pString = string_insline( ch, argument,
string.c:			*ch->desc->pString );
string.c:/*            send_to_char( *ch->desc->pString, ch ); */
string.c:	    string_number( ch, *ch->desc->pString );
string.c:	    *ch->desc->pString =
string.c:		string_replace( *ch->desc->pString, arg2, arg3 );
string.c:	    *ch->desc->pString = string_delline( ch, arg2,
string.c:			*ch->desc->pString );
string.c:            *ch->desc->pString = format_string( *ch->desc->pString );
string.c:	ch->desc->pString = NULL;
string.c:    if ( strlen( *ch->desc->pString ) + strlen( argument ) >= ( MAX_STRING_LENGTH - 100 ) )
string.c:        ch->desc->pString = NULL;
string.c:    strcpy( buf, *ch->desc->pString );
string.c:    free_string( *ch->desc->pString );
string.c:    *ch->desc->pString = str_dup( buf );
t_prog.c:	for (vch = room->people; vch; vch = vch->next_in_room) {
t_prog.c:	    for (vch = tObj->in_room->people; vch; vch = vch->next_in_room) {
t_prog.c:	    for (vch = tObj->carried_by->in_room->people; vch; vch = vch->next_in_room) {
t_prog.c:    for (vmob = ch->in_room->people; vmob != NULL; vmob = vmob->next_in_room)
track.c:    if (!(room = ch->in_room))
track.c:    if (!(exit = ch->in_room->exit[dir]))
track.c:	if (ch->hunting) {
track.c:	    ch->hunting = NULL;
track.c:    if (!(vict = get_char_world(ch, arg)) || !IS_SAME_AREA(ch->in_room,
track.c:    dir = find_first_step(ch->in_room, vict->in_room);
track.c:	ch->hunting = NULL;
track.c:	ch->hunting = NULL;
track.c:	ch->hunting = NULL;
track.c:	    if (!IS_NPC(ch) && ch->pcdata->learned[gsn_track] < number_percent()) {
track.c:		for (vch = char_list; vch; vch = vch->next) {
track.c:		    if (vch->deleted || !IS_NPC(vch) || !can_see(ch, vch) ||
track.c:			!IS_SAME_AREA(ch->in_room, vch->in_room) ||
track.c:			(dir = find_first_step(ch->in_room, vch->in_room)) < 0)
track.c:   IS_SAME_AREA(ch->in_room, ch->in_room->exit[dir]->to_room))
track.c:   for ( vch = char_list; vch; vch = vch->next )
track.c:   if ( vch->deleted || !IS_NPC(vch) )
track.c:	    ch->hunting = vict;
track.c:    if (!ch || ch->fighting || !ch->hunting)
track.c:   if (ch->hunting == tmp)
track.c:    if ( /*!found || */ !can_see(ch, ch->hunting)) {
track.c:	else if (ch->desc)
track.c:	    write_to_buffer(ch->desc, "Track1: You have lost the trail.\n\r", 0);
track.c:	ch->hunting = NULL;
track.c:    dir = find_first_step(ch->in_room, ch->hunting->in_room);
track.c:	    sprintf(buf, "Damn!  Lost %s!", ch->hunting->sex == SEX_FEMALE
track.c:		  ? "her" : ch->hunting->sex == SEX_MALE ? "him" : "it");
track.c:	} else if (ch->desc) {
track.c:		write_to_buffer(ch->desc,
track.c:		write_to_buffer(ch->desc, "\n\rTrack2: You have lost the trail.",
track.c:	ch->hunting = NULL;
track.c:	    sprintf(log_buf, "%s hunting %s at %d.", ch->short_descr,
track.c:		    (IS_NPC(ch->hunting)) ? ch->hunting->short_descr :
track.c:		    ch->hunting->name, ch->hunting->in_room->vnum);
track.c:	    write_to_buffer(ch->desc, log_buf, 0);
track.c:	if (ch->in_room == ch->hunting->in_room) {
track.c:		multi_hit(ch, ch->hunting, TYPE_UNDEFINED);
track.c:	    } else if (ch->desc)
track.c:		write_to_buffer(ch->desc,
track.c:	    ch->hunting = NULL;
update.c:    ch->perm_hit += add_hp;
update.c:	ch->perm_mana += add_mana;
update.c:	ch->perm_bp += add_mana;
update.c:    ch->perm_move += add_move;
update.c:    ch->practice += add_prac;
update.c:	REMOVE_BIT(ch->act, PLR_BOUGHT_PET);
update.c:	    add_prac, ch->practice);
update.c:   add_hp,      ch->perm_hit,
update.c:   add_mana,    ch->perm_mana,
update.c:   add_move,    ch->perm_move,
update.c:   add_prac,    ch->practice );
update.c:   add_hp,      ch->perm_hit,
update.c:   add_mana,    ch->perm_bp,
update.c:   add_move,    ch->perm_move,
update.c:   add_prac,    ch->practice );
update.c:    if (IS_NPC(ch) || ch->level >= L_CHAMP3)
update.c:    ch->exp = UMAX(1000, ch->exp + gain);
update.c:   while ( ( ch->level < LEVEL_HERO && ch->exp >= 1000 * ( ch->level + 1 ) )
update.c:   || ( ch->level < L_CHAMP1 && ch->exp >= 400000 )
update.c:   || ( ch->level < L_CHAMP2 && ch->exp >= 1000000 )
update.c:   || ( ch->level < L_CHAMP3 && ch->exp >= 2000000 ) ) */
update.c:    while (ch->exp >= xp_tolvl(ch)) {
update.c:	ch->level += 1;
update.c:	sprintf(buf, "%s just made level %d!", ch->name, ch->level);
update.c:	info("%s advances to level %d!", (int) ch->name, ch->level);
update.c:	gain = ch->level * 3 / 2;
update.c:	gain = UMIN(5, ch->level);
update.c:   if ( ch->level < LEVEL_IMMORTAL && ch->class == CLASS_VAMPIRE )
update.c:   if ( !IS_SET( ch->in_room->room_flags, ROOM_INDOORS ) )
update.c:	switch (ch->position) {
update.c:	    gain += (ch->pcdata->learned[gsn_fastheal] > 0
update.c:		&& ch->pcdata->learned[gsn_fastheal] > number_percent())?
update.c:	    gain += (ch->pcdata->learned[gsn_fastheal] > 0
update.c:		&& ch->pcdata->learned[gsn_fastheal] > number_percent())?
update.c:	    gain += (ch->pcdata->learned[gsn_fastheal] > 0
update.c:		&& ch->pcdata->learned[gsn_fastheal] > number_percent())?
update.c:	if (ch->pcdata->condition[COND_FULL] == 0)
update.c:	if (ch->pcdata->condition[COND_THIRST] == 0
update.c:   if ( ch->class == CLASS_VAMPIRE )
update.c:   if ( !IS_SET( ch->in_room->room_flags, ROOM_INDOORS ) )
update.c:    if (ch->race == RACE_TROLL)
update.c:    if (is_raffected(ch->in_room, gsn_ward_heal)) {
update.c:    if (IS_SET(ch->in_room->room2_flags, ROOM_RENTED) && ch->money.silver > 0)
update.c:    if (IS_SET(ch->act2, PLR2_TENNANT) && ch->money.silver > 0)
update.c:	ch->money.silver -= 10;
update.c:    return UMIN(gain, MAX_HIT(ch) - ch->hit);
update.c:	gain = ch->level;
update.c:	gain = UMIN(5, ch->level / 2);
update.c:	switch (ch->position) {
update.c:	if (ch->pcdata->condition[COND_FULL] == 0)
update.c:	if (ch->pcdata->condition[COND_THIRST] == 0
update.c:	if (ch->race == RACE_ELF || ch->race == RACE_ELDER)
update.c:    return UMIN(gain, MAX_MOVE(ch) - ch->mana);
update.c:	gain = ch->level;
update.c:	gain = UMAX(15, 2 * ch->level);
update.c:	switch (ch->position) {
update.c:	if (ch->pcdata->condition[COND_FULL] == 0)
update.c:	if (ch->pcdata->condition[COND_THIRST] == 0
update.c:    return UMIN(gain, MAX_MOVE(ch) - ch->move);
update.c:    if (value == 0 || IS_NPC(ch) || ch->level >= L_APP)
update.c:    if (ch->level >= LEVEL_HERO && iCond != COND_DRUNK)
update.c:    condition = ch->pcdata->condition[iCond];
update.c:    ch->pcdata->condition[iCond] = URANGE(0, condition + value, 58);
update.c:    hploss = (ch->level < 10) ? 1 : (ch->level < 20) ? 2 : 3;
update.c:    if (ch->pcdata->condition[iCond] == 0) {
update.c:	if ((iCond != COND_DRUNK) && (ch->hit - hploss) > 5)
update.c:	    ch->hit = (ch->hit - hploss);
update.c:    for (ch = char_list; ch; ch = ch->next) {
update.c:	if (ch->deleted)
update.c:	if (IS_NPC(ch) && (ch->wait -= PULSE_MOBILE) < 0)
update.c:	    ch->wait = 0;
update.c:	    || !ch->in_room
update.c:	    || ch->wait > 0)
update.c:	if (ch->spec_fun != 0) {
update.c:	    if ((*ch->spec_fun) (ch))
update.c:	if (ch->position < POS_STANDING)
update.c:	if (ch->in_room->area->nplayer > 0) {
update.c:	    if (ch->position < POS_STANDING)
update.c:	if (IS_SET(ch->act, ACT_SCAVENGER)
update.c:	    && ch->in_room->contents
update.c:	    for (obj = ch->in_room->contents; obj; obj = obj->next_content) {
update.c:	if (!IS_SET(ch->act, ACT_SENTINEL)
update.c:	    && (pexit = ch->in_room->exit[door])
update.c:	    && !ch->hunting
update.c:	    && (!IS_SET(ch->act, ACT_STAY_AREA)
update.c:		|| pexit->to_room->area == ch->in_room->area)) {
update.c:	    if (ch->position < POS_STANDING)
update.c:	if (ch->hit < (MAX_HIT(ch) / 2)
update.c:	    && (pexit = ch->in_room->exit[door])
update.c:		 rch = rch->next_in_room) {
update.c:		if (rch->deleted)
update.c:	if (ch->hunting)
update.c:    for (ch = char_list; ch; ch = ch->next) {
update.c:	if (ch->deleted)
update.c:	    && (!ch->desc || ch->desc->connected == CON_PLAYING)
update.c:	    && ch->level >= 2
update.c:	    && ch->save_time < save_time) {
update.c:	    save_time = ch->save_time;
update.c:	if (ch->position >= POS_STUNNED) {
update.c:	    if (ch->hit < MAX_HIT(ch))
update.c:		ch->hit += hit_gain(ch);
update.c:	    if (ch->mana < MAX_MANA(ch))
update.c:		ch->mana += mana_gain(ch);
update.c:	    if (ch->move < MAX_MOVE(ch))
update.c:		ch->move += move_gain(ch);
update.c:	    if (ch->position == POS_STUNNED) {
update.c:		ch->position = POS_STANDING;
update.c:	    && !ch->fighting) {
update.c:	    && !ch->fighting) {
update.c:	    REMOVE_BIT(ch->affected_by2, AFF_BERSERK);
update.c:	if (ch->position == POS_STUNNED)
update.c:	if (!IS_NPC(ch) && (ch->level < LEVEL_IMMORTAL
update.c:			    || (!ch->desc && !IS_SWITCHED(ch)))) {
update.c:		if (--obj->value[2] == 0 && ch->in_room) {
update.c:		    --ch->in_room->light;
update.c:	    if (++ch->timer >= 10) {
update.c:		if (!ch->was_in_room && ch->in_room) {
update.c:		    ch->was_in_room = ch->in_room;
update.c:		    if (ch->fighting)
update.c:	    if (ch->timer > 20 && !IS_SWITCHED(ch))
update.c:	for (paf = ch->affected; paf; paf = paf->next) {
update.c:	for (paf = ch->affected2; paf; paf = paf->next) {
update.c:	for (pd = ch->powered; pd; pd = pd_next) {
update.c:	if (ch->gspell && --ch->gspell->timer <= 0) {
update.c:	if (ch->ctimer > 0)
update.c:	    ch->ctimer--;
update.c:	    damage(ch, ch, ch->level / 4, gsn_incinerate);
update.c:	} else if (ch->position == POS_INCAP) {
update.c:	} else if (ch->position == POS_MORTAL) {
update.c:	for (ch = char_list; ch; ch = ch->next) {
update.c:	    if (ch->deleted)
update.c:	ch_next = ch->next;
update.c:	if (ch->summon_timer <= 0);
update.c:	    ch->summon_timer--;
update.c:	if (IS_NPC(ch) && ch->summon_timer == 0) {
update.c:/*          || ch->level >= LEVEL_IMMORTAL */
update.c:	    || !ch->in_room)
update.c:	for (mch = ch->in_room->people; mch; mch = mch->next_in_room) {
update.c:		|| mch->deleted
update.c:/*              || !IS_SET( mch->act, ACT_AGGRESSIVE ) */
update.c:		|| mch->fighting
update.c:/*              || ( IS_SET( mch->act, ACT_WIMPY ) && IS_AWAKE( ch ) ) */
update.c:		|| mch->wait > 0
update.c:		|| ch->wait > 0)
update.c:	    if (IS_NPC(mch) && mch->mpactnum > 0
update.c:		&& mch->in_room->area->nplayer > 0) {
update.c:		for (tmp_act = mch->mpact; tmp_act != NULL;
update.c:		for (tmp_act = mch->mpact; tmp_act != NULL; tmp_act = tmp2_act) {
update.c:		mch->mpactnum = 0;
update.c:		mch->mpact = NULL;
update.c:	    if (!IS_SET(mch->act, ACT_AGGRESSIVE)
update.c:		|| (IS_SET(mch->act, ACT_WIMPY) && IS_AWAKE(ch))
update.c:	    for (vch = mch->in_room->people; vch; vch = vch->next_in_room) {
update.c:		    || vch->deleted
update.c:		    || vch->level >= LEVEL_IMMORTAL)
update.c:		if ((!IS_SET(mch->act, ACT_WIMPY) || !IS_AWAKE(vch))
update.c:/*        if ( IS_NPC( mch ) && mch->mpactnum > 0
update.c:   && mch->in_room->area->nplayer > 0 )
update.c:   for ( tmp_act = mch->mpact; tmp_act != NULL;
update.c:   for ( tmp_act = mch->mpact; tmp_act != NULL; tmp_act = tmp2_act )
update.c:   mch->mpactnum = 0;
update.c:   mch->mpact    = NULL;
update.c:	    for (paf = ch->affected; paf; paf = paf_next) {
update.c:		if (paf->deleted || ch->deleted) {
update.c:		    if (ch->affected == paf) {
update.c:			ch->affected = paf->next;
update.c:			for (prev = ch->affected; prev; prev = prev->next) {
update.c:			    sprintf(log_buf, "Char: %s", ch->name);
update.c:	    for (paf = ch->affected2; paf; paf = paf_next) {
update.c:		if (paf->deleted || ch->deleted) {
update.c:		    if (ch->affected2 == paf) {
update.c:			ch->affected2 = paf->next;
update.c:			for (prev = ch->affected2; prev; prev = prev->next) {
update.c:			    sprintf(log_buf, "Char: %s", ch->name ? ch->name
update.c:	    ch_next = ch->next;
update.c:	    if (ch->deleted) {
update.c:		    char_list = ch->next;
update.c:			    prev->next = ch->next;
update.c:				ch->name);
update.c:    for (ch = char_list; ch != NULL; ch = ch->next) {
update.c:	if (ch->deleted)
update.c:	if (--ch->combat_timer < 0)
update.c:	    ch->combat_timer = 0;
update.c:		    arena.cch->name, arena.och->name, arena.award);
update.c:		      (int) (arena.cch->name), arena.award);
update.c:		  (int) (arena.och->name), (int) (arena.cch->name));
update.c:		  (int) (arena.cch->name), 0);
update.c:    arena.cch->money.gold += ((arena.award * 4) / 5);
update.c:    arena.cch->gold += ((arena.award * 4) / 5);
update.c:	if (!(ch->in_room))
update.c:	if (ch->level < L_APP)
update.c:	    if (IS_SET(ch->in_room->room_flags, ROOM_DAMAGE)) {
update.c:		/*  if ( ch->hit <= ch->in_room->rd ) */
update.c:		damage(ch, ch, ch->in_room->rd, TYPE_UNDEFINED);
update.c:   if ( !( ch->in_room ) )
update.c:   if ( ch->level < L_APP && is_class( ch, CLASS_VAMPIRE ) )
update.c:   if ( !IS_SET( ch->in_room->room_flags, ROOM_INDOORS ) )
update.c:   damage( ch, ch, (ch->level / 2) , TYPE_UNDEFINED );
update.c:   ch->bp -= ch->bp / 6;
